#+TITLE: The Emergence of Patterns in Nature and Chaos Theory
:PREAMBLE:
#+OPTIONS: broken-links:auto todo:nil H:9 tags:t
#+STARTUP: overview
#+AUTHOR: Ryan Greenup & James Guerra
#+INFOJS_OPT: view:showall toc:3
#+PLOT: title:"Citas" ind:1 deps:(3) type:2d with:histograms set:"yrange [0:]"
#+OPTIONS: tex:t
# #+TODO: TODO IN-PROGRESS WAITING DONE
#+CATEGORY: TAD
:END:
:HTML:
#+INFOJS_OPT: view:info toc:3
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="./resources/style.css">
# #+CSL_STYLE: /home/ryan/Templates/CSL/nature.csl
:END:
:R:
#+PROPERTY: header-args:R :session TADMain :dir ./ :cache yes :eval never-export :exports both
# exports: both (or code or whatever)
# results: table (or output or whatever)
:END:
:LATEX:
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,11pt,twoside]
#+LATEX_HEADER: \IfFileExists{./resources/style.sty}{\usepackage{./resources/style}}{}
#+LATEX_HEADER: \IfFileExists{./resources/referencing.sty}{\usepackage{./resources/referencing}}{}
#+LATEX_HEADER: \addbibresource{../Resources/references.bib}
#+LATEX_HEADER: \usepackage[mode=buildnew]{standalone}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usetikzlibrary{decorations.fractals}
#+LATEX_HEADER: \usetikzlibrary{lindenmayersystems}
:END:
@@latex: \newpage @@
* TODO Introduction                                                                :Ryan:
Fractals are complex shapes that often occur from natural processes, in this
report we hope to investigate the emergence of patterns and complex structurs
from natural phenoma. We begin with an investigation into fractals and the
concept of dimension and then discuss links between fractal patterns and natural
processes.

** A note on Images in this report
Although the images in this document may appear to be quite small, they are high quality PNG images and one of the luxuries of PDF is that the embeded media is near lossless, so to perceive greater detail in an image it is sufficient to simply zoom in and the greater detail should be rendered. [fn:: Apparently it's also possible to embed live GIFs into PDF as well which would have been nice to do had time permitted, see for example the ~Animate~ package for \LaTeX cite:CTANPackageAnimate and [[https://tex.stackexchange.com/questions/5396/is-there-any-way-to-include-an-animated-gif-directly][this discussion]] cite:PdftexThereAny generally.]

* Fractals
** Definition of a Fractal                                                     :Ryan:

Benoît Mandelbrot coined the term fractal in 1975 cite:gomoryBenoitMandelbrot19242010 and defined it his 1982 book /The Fractal Geometry of Nature/ [[cite:mandelbrotFractalGeometryNature1982][p. 15]] :

#+begin_quote
/A fractal is by definition a set for which the Hausdorff Besicovitch dimension
strictly exceeds the topological dimension./

/Every set with a noninteger \(D\) is a fractal./
#+end_quote

The topoligical dimension is a strictly integer value that describes the natural dimension used to describe a shape cite:sandersonFractalsAreTypically2017,
for example the /Koch Snowflake/ (shown in figure [[koch-snowflake]]) is composed of
just a line, so it's topological dimension would simply be 1, it's /fractal
dimension/ however is shown to be \(\frac{\ln\left( 4 \right)}{\ln\left( 3
\right)}\) at eqref:eq:koch-dim in \S[[#topological-equivalence]].

Many authors seem to accept this earlier definition (see e.g. [[cite:vicsekFractalGrowthPhenomena1992][\S2.2]] and [[cite:telChaoticDynamicsIntroduction2006][\S2.1]]),
this definition however does not capture many edge-case fractals
 [[cite:edgarMeasureTopologyFractal2008a][VII]] and in reprintings of /The
Fractal Geometry of Nature/ Mandelbrot himself commented that in hindsight it
may have been more appropriate [[cite:mandelbrotFractalGeometryNature1982][p. 459]]:

#+begin_quote
/to leave the term "fractal” without a pedantic definition, to use “fractal dimension” as a generic term applicable to all the variants in Chapter 39, and to use in each specific case whichever definition is the most appropriate/.
#+end_quote

Gerald Edgar, in his 2008 book /Measure, topology, and fractal geometry/
rejected this view because "/a term without a 'pedantic definition' cannot be
studied mathematically/" [[cite:edgarMeasureTopologyFractal2008a][VII]] and
presented a more robust definition in Ch. 6 of that book, it was however
accepted that the loose definition of fractal dimension is convenient and was
indeed adopted in that work.

Although reviewing the precise definition of a fractal would have been very
interesting, without a cursory knowledge of fractals generally this would have
been very time consuming and outside the scope of this report [fn:: Mandelbrot
also discussed fractals of a Euclidean and Reimannian nature,
[[cite:mandelbrotFractalGeometryNature1982][p. 361]], this again is interesting
but too specific for the broad nature of our investigation].

Some authors simply define a fractal as a shape that /shows irregularities at
all scales/ [[cite:gouyetPhysicsFractalStructures1996][p. 1]] and in his 2003
book, /Fractal Geometry/, Facloner suggested that it is more convenient to
describe a fractal by a list of properties characteristic of such shapes [fn::
Much like the definition of life in the field of biology] because of the
difficulty in defining a fractal in a way that can encompass all edge cases and
provides the following charecteristics
[[cite:falconerFractalGeometryMathematical2003b][p. xxv]]:

    - Detail at all scales
    - Cannot be described in a traditional geometric way
    - May have some form of approximate self similarity
    - Usually the fractal dimension is greater than its topological dimension
    - In many cases defined very simply, perhaps recursively

This will be the approach adopted in this report.

It's interesting to note that many authors refer to complex natural shapes as
fractals, such as coastlines (see e.g.
cite:jiangFractalAnalysisComplexity1998,zhuFractalMechanismCoastline2002,zhongFractalPropertiesShoreline2017)
much in the spirit of Mandelbrot's paper /How long is the Coastline of Britain/
cite:mandelbrotHowLongCoast1967, although he coined the term fractal many years
after this paper, presumably he might have had this in mind [fn:: Mandelbrot also
spent much time looking at the roughness of financial markets and so presumably
may have had that in mind as well, see e.g.
cite:gomoryBenoitMandelbrot19242010,mandelbrotMisBehaviourMarkets2008 ] when
framing the definition so this issue in clearly defining what a fractal is
appears on the surface to be a purely mathematical one (as opposed to a
practical or applied one).

The Wikipedia page on fractals cite:Fractal2020 also points out that a
fractal is nowhere differentiable, this would be because a fractal is
nowhere smooth, which is certainly an important and distinguishing feature worth noting.

** Fractals Generally                                                          :James:
Dimension is the main defining property of a fractal. As aforementioned above, the Hausdorff dimension is a unique number in that, if we take some shape in $\mathbb{R}^{n}$, and the Hausdorff dimension converges to some number, then the dimension of the shape is given by that number. Otherwise, it will equal $0$ or $\infty$. For example, if we want to evaluate the dimension of a square and we use a 1-Dimensional shape as the cover set to calculate the Hausdorff dimension, we will get $\infty$. On the other hand, if we do the same with a 3-Dimensional shape, we will get 0. And finally if we use a 2-Dimensional shape, the Hausdorff dimension will evaluate to 2. This same notion is important when computing the dimension of a more complex shape such as the Koch snowflake.

To define a fractal, we must define it's dimension. Whilst some research states that a fractal has a non-integer dimension, this is not true for all fractals. Although, most fractals like the Koch snowflake do in fact have non-integer dimensions, we can easily find a counter example namely, the Mandelbrot set. The Mandelbrot set lies in the same dimension as a square, a 2-Dimensional shape. However, we give recognition to the complexity and roughness of the Mandelbrot set which clearly distiguishes itself from a square. Beneath the Mandelbrot set's complexity are exact replicates of the largest scaled Mandelbrot set, i.e a self similar shape. Furthermore, although the Mandelbrot set has an integer dimension, the self similarity and complexity is what also defines its fractal nature.

** Fractal Dimension                   
The concept of a non-integer dimension may at first seem odd, particularly given that the familiar definition from linear algebra (concerned with the number of vectors within a basis for a vector space cite:larsonElementaryLinearAlgebra1991) is strictly an integer value, but in the early \(20^{\mathrm{th}}\) century mathematicians recognised the shortcomings of this definition [[cite:mandelbrotFractalGeometryNature1982][Ch. 3]].

In this section we hope to convince the reader that there is grounds for
extending the definition of dimension and as a matter of fact many definitions
for non-integer dimensions of a shape have been proposed (see generally
[[cite:mandelbrotFractalGeometryNature1982][Ch. 39]] and
[[cite:gouyetPhysicsFractalStructures1996][\S 1.3]]) of these the Hausdorff Dimension (and corresponding Hausdorff Measure) is
considered to be the most important and mathematically robust
[[cite:falconerFractalGeometryMathematical2003b][p. 27]], while the /Box-Counting Dimension/ (introduced in \S [[#box-count-dim]])
has the most practical applications in science
[[cite:peitgenChaosFractalsNew2004][p. 192]].

The Hausdorff dimension is more like counting balls than boxes and is identical
to the Box-Counting Dimension in many cases, it's more general but harder to define
cite:sandersonFractalsAreTypically2017, An extension to the work of this report
would be to show the mathematical connections between the Hausdorff Dimension
and box counting dimension with respect to the fractals generated and measured.


*** Topological Equivalence                                                   :Ryan:
:PROPERTIES:
:CUSTOM_ID: topological-equivalence
:END:


Topology is an area of mathematics concerned with ideas of continuity through the study of figures that are preserved under homeomorphic transformations cite:gilmoreTopologyChaosAlice2002 , where two figures are said to be homeomorphic if there is a continuous bijective mapping between the two shapes [[cite:peitgenChaosFractalsNew2004][p. 105]]
.
[fn:: For further reading on this topic see [[cite:peitgenChaosFractalsNew2004][p. 106]] ]

So for example deforming a cube into a sphere would be homeomorphic, but deforming a sphere into a torus would not, because the the surface of the shape would have to be compromised to acheive that.

As mentioned above, historically, the concept of dimension was a difficult problem with a tenuous
definition.  Although an inutitive definition related the dimension of a shape to
the number of parameters needed to describe that shape, this definition is not
sufficient to be preserved under a homeomorphic transform.

Consider the koch fractal and snowflake in figures [[koch-line]] and [[koch-snowflake]], at each iteration (\(n\)) the perimeter is given by \(p_{n}= \left(\frac{4}{3} \right)p_{n-1}\) and the number of edges by \(N_{n}\):



\begin{align}
N_{n} &= N_{n-1} \cdot 4 \\
&= 3 \cdot 4^{n}
\end{align}

If the length of any individual side was given by $l$ and scaled by some value $s$ then the length of each individual edge would be given by:

\begin{align}
l = \frac{s \cdot l_{0}}{3^{n}}
\end{align}

The total perimeter would be given by:

\begin{align}
p_{n} &= N_{n} \times l \\
&= 3\cdot 4^{n} \times \frac{s \cdot l_{o}}{3^{n}} \\
&= 3 \cdot s \cdot  l_{0} \left( \frac{4}{3} \right)^{n}\\
 \implies p_{n} \cdot s & \propto \left(\frac{4}{3}\right)^{n}\\
& \implies  n = \frac{\log\left( 4 \right)}{\log\left( 3 \right)} \approx 1.26 \label{eq:koch-dim}
\end{align}

This means that if the koch snowflake is scaled by any factor, the resulting perimeter of the snowflake will not be linearly proportional to the scaling factor, as would be the case with an ordinary shape such as a square or a circle, it will instead by proportional to 1.26, this should hopefully motivate the need to more clearly define both the concept of measure (in this case the permiter [fn:: Grant Sanderson equates the measure of a fractal as analogous to mass, which is a very helpful way comparison cite:sandersonFractalsAreTypically2017]) and dimension.

To clarify the koch snowflake, is defined such that there are no edges, every point on the "curve" is the vertex of an equilateral triangle, this shape has no smooth edges.

See [[cite:strogatzNonlinearDynamicsChaos2015][p. 414]] and [[cite:baderSpacefillingCurvesIntroduction2013][\S 5.4]] for further reading on the self similar dimension of the /Koch Snowflake/.

This approach of considering the scaling factor of a deterministic fractal is
known as the similarity dimension [[cite:strogatzNonlinearDynamicsChaos2015][p.
413]] and should be equal to the Hausdorff and box counting dimensions for most
fractals. For fractals that aren't so obviously self similar it won't be
feasible however [[cite:liIntegrationFuzzyLogic2006][p. 393]], for example with
the julia set [fn:: It is indeed shown to be
mostly constant at all scales in section \S [[#jl-set-dim]] ] or the outline of a coastline it is not immediately clear if the
the dimension would be constant at all scales



#+NAME: koch-line
#+CAPTION: Progression of the Koch Snowflake
#+attr_html: :width 400px
#+attr_latex: :width 9cm
[[file:media/tikz/Koch_line.png]]
# \includestandalone[]{.media/tikz/Koch_line.png]]

#+NAME: koch-snowflake
#+CAPTION: Progression of the Koch Snowflake
#+attr_html: :width 400px
#+attr_latex: :width 9cm
[[file:media/tikz/Snowflake.png]]
# \includestandalone[]{./media/tikz/Snowflake.tex}

@@latex: \newpage @@
*** Hausdorff Measure                                                         :Ryan:
:PROPERTIES:
:CUSTOM_ID: hausdorff-measure
:END:

The Hausdorff dimension depends first on a rigorous definition of measure, this is distinct from the box counting approach in that it is more mathematically rigorous, it is however complex and in practice this report will be concerned with implementing the box counting dimension. [fn:res]

:IMAGE:
# #+attr_latex: :width 12cm
#+NAME: fig:ball-covering
#+CAPTION: The Hausdorff Measure, in this case area, of an arbitrary surface approximated by the cross section of litte balls of diameter \(< \delta \), this is reproduced from /Measure, Topology and Fractal Geometry/ [[cite:edgarMeasureTopologyFractal2008a][p. 166]] because it so elegantly illustrates the concept of the Hausdorff Measure.
#+attr_html: :width 400px
#+ATTR_LATEX: :float wrap :width 0.38\textwidth
[[file:media/edgar_181_of_292.png]]
:END:

Let $F$ be some arbitrary subset of euclidean space $\mathbb{R}^n$, [fn:: A subset of euclidean space could be interpreted as an uncountable set containing all points describing that region]

Let \(U\) be a subset of euclidean space \(\mathbb{R}^{n}\) such that the diamater is defined as the greatest distance between any of the points:

\[
\left\lvert U \right\rvert = \mathrm{sup}\left(\left\{ \left\lvert x- y \right\rvert \enspace : \enspace x,y \in U\right\}  \right)
\]

Consider a collection of these sets, $G = \left\{U_i: i \in \mathbb{Z}^{+}\right\}$ such that each element has a diameter less than \(\delta\).


The motivating idea is that if the elements of $G$ can be laid ontop of
$F$ then \(G\) is said to be a $\delta$ -cover of $F$, more rigorously, \(G\) is a \(\delta\)-cover of \(F\) if: [fn:: Falconer defines this as \(\bigcup_{i=1}^{\infty}\) [[cite:falconerFractalGeometryMathematical2003b][\S 2.1]],
presumably treating any index value greater than the cardinality of the set as \(\emptyset\), this is particularly ambiguous and we have avoided it, an alternative way to present that might be \(\bigcup^{\#G}_{i=0}\) where \(\#G\) denotes the cardinality or \(G\) (or \(\infty\) if it is uncountable). The use of \(\#\square\) to denote cardinality was introduced by Knuth in /Concrete Mathematics/ cite:grahamConcreteMathematicsFoundation1994 and is convenenient in that it avoids any ambiguity  with diamater (\(\left\lvert \square \right\rvert \)).]

\begin{align}
    F \subset \bigcup_{U\in B} \left( U \right) \quad :\quad 0 \leq \left\lvert U \right\rvert \leq \delta \label{eq:hausdorff-covering}
\end{align}



An example of this covering is provided in figure [[hausdorff-covering]], in that example the figure on the right is covered by squares, which each could be an element of $\{U_{i}\}$, it is important to note, by this definition, that the shapes represented by \(U\) could be any arbitrary figure [[cite:falconerFractalGeometryMathematical2003b][\S 2.1]] the size of which may vary in size so long as the diameter is less than \(\delta\).


So for example:

- $F$ could be some arbitrary 2D shape, and $U_{i}$ could be
  a collection of identical squares, OR

- $F$ could be the outline of a coastline and $U_{i}$ could be a set of circles, OR

- $F$ could be the surface of a sheet and $U_{i}$ could be a set of spherical balls as shown in figure [[fig:ball-covering]]

  + Some authors suggest that the Haussdorff Measure is concerned primarily with round covering objects (see e.g. cite:sandersonFractalsAreTypically2017), this is well illustrated by figure [[fig:ball-covering]], however in truth it is merely more convenient to use round shapes for most fractals.

  + The use of balls is a simpler but equivalent approach to the theory [[cite:falconerFractalGeometryMathematical2003b][\textsection 2.4 ]] because any set of diamater $r$ can be enclosed in a ball of radius $\frac{r}{2}$ [[cite:edgarMeasureTopologyFractal2008][p. 166]]

- $F$ could be a more abstracted figure like figures [[hausdorff-covering]] or [[abstract-shape]]  and $\{U_{i}\}$ a collection of various different lines, shapes or 3d objects.

The Hausdorff measure is concerned with only the diamater of each element of $\{U_{i}\}$ and considers \(\sum_{U \in G} \left[\left\lvert U\right\rvert^{s}\right]\) where each element \(U\in G\) is arranged so as to minimize the value of the summation [[cite:falconerFractalGeometryMathematical2003b][p. 27]]
, the \(\delta\)-Hausdorff is hence defined, for various dimensions \(s\):

\begin{align}
\mathcal{H}^s_{\delta}\left( F \right)= \inf \left\{ \sum_{U\in G}   \left\lvert U_i \right\rvert^s \enspace : \enspace  \left\{U_i\right\} \text{ is a } \delta \text{-cover of } F \right\}, \quad \delta, s > 0 \label{eq:delta-measure}
\end{align}

The value of \(s\) can be different regardless of the dimension of \(F\), for example if \(F\) was an arbitrary 2D shape the value of \(\mathcal{H}_{\delta}^{2}\left(F\right)\)
is equivalent to considering the number of shapes \(U\in G\) (e.g. boxes, discs etc.), of
diamater $\leq \delta$ that will cover over a shape as shown in figure
[[hausdorff-covering]], the delta Haussendorf measure
$\mathcal{H}^{2}_{\delta} \left(F\right)$ will be the area of the boxes when
arranged in such a way that minimises the area.

As $\delta$ is made arbitrarily small $\mathcal{H}_{\delta}^{s}$ will approach some limit, in the case of figures [[hausdorff-covering]]  and [[abstract-shape]] the value of $\mathcal{H}^{2}_{\delta}$ will approach the area of the shape as $\delta \rightarrow 0$ and so the $s^{th}$ dimensional Hausdorff measure is given by:

\begin{align}
\mathcal{H}^{s} = \lim_{\delta \rightarrow 0}\left( \mathcal{H}^{s}_{\delta} \right) \label{eq:limit-haus}
\end{align}

This is defined for all subsets of \(\mathbb{R}^n\) for example the value of  $\mathcal{H}^{2}$ corresponding to figure [[abstract-shape]] will be limit that boxes would approach when covering that area, which would be the area of the shape ($4\times 1^2 + 4\times \pi\times \frac{1}{2^2} + \frac{1}{2}\times 1 \times \sin{\frac{\pi}{3}}$).





# #+attr_latex: :width 5cm
#+ATTR_LATEX: :float wrap :width 0.38\textwidth
#+NAME: hausdorff-covering
#+CAPTION: The blue outline corresponds to some \(F \subset \mathbb{R}^{2}\), covered by various grey objects, each of which represent an element from the set $U_{i}$. The grey shapes all have a diameter less than \(\delta\) and so this  \(\bigcup \left[U_{i}\right]\) would be a \(\delta\)-covering of \(F\).
#+attr_html: :width 400px
[[file:notes/HaussDorf_Dim_Ink.svg]]




**** Lower Dimension Hausdorff Measurements
***** Examples
Consider again the example of a 2D shape, the value of $\mathcal{H}^{1}$ would still be defined by eqref:eq:delta-measure, but unlike $\mathcal{H}^{2}$ in \S [[#hausdorff-measure]] the value of $\left\lvert U_i \right\rvert^1$ would be considered as opposed to $\left\lvert U_i \right\rvert^2$ (i.e. the diamater as opposed to the diameter squared).

As $\delta$ is made arbitrarily small the boxes [fn:: Even though \(U\) may contain a variety of shapes, eqref:eq:delta-measure is concerned only with the power of there diameter, so in this sense the limit is concerned only with boxes corresponding to the diameter of the elements of \(U\)] that cover the shape are made also to be arbitrarily small. Although the area of the boxes must clearly be bounded by the shape of $F$, if one imagines an infinite number of infinitely dense lines packing into a 2D shape with an infinite density it can be seen that the total length of those lines will be infinite and so the limit in eqref:eq:limit-haus will increase without bound.

To build on that same analogy, another way to imagine this is to pack a 2D shape with straight lines, the total length of all lines will approach the same value as the length of the lines of the squares as they are packed infinitely densely. Because lines cannot fill a 2D shape, as the density of the lines increases, the overall length will increase without bound.

This is consistent with factals as well, consider the koch snowflake introduced in section [[#topological-equivalence]] and shown in figure [[koch-line]], the dimension of this shape, as shown in \S [[#topological-equivalence]] is greater than 1, and the number of lines necessary to describe that shape is also infinite because every point of the "curve" is a point of an equilateral triangle.

***** TODO Formally
If the dimension of $F$ is less than $s$, the Hausdorff Measure will be given by:

\begin{align}
\mathrm{dim}\left(  F \right ) < s \implies \mathcal{H}^{s} \left( F \right)  = \infty
\end{align}

**** Higher Dimension Hausdorff Dimension


For small values of $s$ (i.e. less than the dimension of  $F$), the value of $\mathcal{H}^s$  will be $\infty$.

Consider some value $s$ such that the Hausdorff measure is not infinite, i.e. values of $s$:

\[
\mathcal{H}^s = L \in \mathbb{R}
\]

Consider a dimensional value $t$ that is larger than  $s$ and observe that:

\begin{align*}
0<s<t  \implies   \sum_{i}  \left[ \left\lvert U_i \right\rvert^t \right] &= \sum_{i}\left[ \left\lvert U_i \right\rvert^{t- s} \cdot  \left\lvert U_i \right\rvert^s \right] \\
&\leq \sum_{i} \left[ \delta^{t - s} \cdot \left\lvert U_i \right\rvert^s  \right]    \\
&= \delta^{t- s}\sum_{i}   \left[ \left\lvert U_i \right\rvert^s \right] 									   \\
\end{align*}

Now if $\lim_{\delta \rightarrow 0}\left[ \sum_{i}   \left\lvert U_i \right\rvert^s \right]$ is defined as a non-infinite value:

\begin{align}
    \lim_{\delta \rightarrow 0} \left( \sum_{i}   \left[ \left\lvert U_i \right\rvert^t \right]  \right) & \leq \lim_{\delta}\left( \delta^{t- s} \sum_{i}   \left[ \left\lvert U_i \right\rvert^s \right]  \right) \\
&\leq \lim_{\delta \rightarrow 0}\left( \delta^{t - s} \right) \cdot  \lim_{\delta \rightarrow 0}\left( \sum_{i} \left[ \left\lvert U_i \right\rvert^s \right]    \right) \\
&\leq 0
\end{align}

and so we have the following relationship:

\begin{align}
    \mathcal{H}^{s} \left(F\right) \in \mathbb{R}^{+}  \implies  \mathcal{H}^t\left( F \right)= 0 \quad \forall t > s \label{eq:hdfzero}
\end{align}

Hence the value of the s-dimensional /Hausdorff Measure/, $s$ is only a finite, non-zero value, when $s = \mathrm{dim}_{H}\left( F \right)$.



#+NAME: hausdorff-vals
#+CAPTION: The value of the s-dimensional /Hausdorff Measure/ of some subset of /Euclidean space/ $F\in \mathbb{R}^{n}$ is 0 or $\infty$ when the dimension of $F$ is not equal to $s$.
#+attr_html: :width 400px
#+attr_latex: :width 9cm
[[file:media/tikz/hausdorff-dimension-plot.png]]

*** Hausdorff Dimension                                                       :Ryan:

# #+attr_latex: :width 0.38\textwidth :float wrap
#+NAME: abstract-shape
#+CAPTION: A disconnected subset of $\mathbb{R}^{2}$, the squares have a diameter of $\sqrt{2}$, the circles 1 and the equilateral triangles 1.
#+attr_html: :width 200px
#+attr_latex: :width 0.28\textwidth :float wrap
[[file:media/Arbitrary-F-Shape.svg]]


The value $s$ at which $\mathcal{H}^{s}$ eqref:eq:hdfzero changes from $\infty$ to 0, shown in figure [[hausdorff-vals]],  is the defined to be the /Hausdorff Dimension/ [[cite:falconerFractalGeometryMathematical2003b][\S 2.2]], it is a generalisation of the idea of dimension that is typically understood with respect to ordinary figures.
# *** TODO See also
# I feel very inclided to read [[https://warwick.ac.uk/fac/sci/maths/people/staff/mark_pollicott/p3/tehran.pdf][these notes]] [fn:: [[file:~/Dropbox/Studies/2020Spring/QuantProject/Current/Python-Quant/Resources/Uncorrected-Warwick-BoxCount-Hausdorff-Notes.pdf][Local Copy]]]

*** Box Counting Dimension                                                    :James:
:PROPERTIES:
:CUSTOM_ID: box-count-dim
:END:
While the Hasudorff dimension is the first formal definition to measure
the roughness of a fractal, there are several other definitions of dimension
that have stemmed from this. Namely, the box-counting dimension. The box
counting method is widely used as it is relatively easy to calculate [[cite:falconerFractalGeometryMathematical2003b][p. 41]]
and in many cases is equal to the /Hausdorff Dimension/  [[cite:markpollicottFractalsDimensionTheory2005][p. 11]] (see generally cite:ListFractalsHausdorff2020).
The box-counting dimension is defined as the following from
cite:falconerFractalGeometryMathematical2003:

Let $F$ be any non-empty bounded subset of $\mathbb{R}^n$ and let $N_\delta(F)$ be the smallest
number of sets of diameter at most $\delta$ which can cover $F$. The /lower/ and /upper/
box-counting dimensions of $F$ respectively are defined as

\begin{equation*}
    \underline{\text{dim}}_BF = \underline{\lim}_{\delta \to 0} \frac{\ln N_\delta(F)}{-\ln \delta}
\end{equation*}
\begin{equation*}
\overline{\text{dim}}_BF = \overline{\lim}_{\delta \to 0} \frac{\ln N_\delta(F)}{-\ln \delta}
\end{equation*}

When the /lower/ and /upper/ box-counting dimensions of $F$ are equal, then

\begin{equation*}
\text{dim}_BF = \lim_{\delta \to 0} \frac{\ln N_\delta(F)}{-\ln \delta}
\end{equation*}

For example, suppose we had a square with side length 1 and we use smaller squares of side
length $\frac{1}{\delta}$ to cover the larger square. This would mean that one side of the
large square would need $\delta$ $\frac{1}{\delta}$ small squares, and so to cover
the entire square, one would need $n^2$ small squares, i.e. $N_{\frac{1}{n}}(F) = n^2$. Now,
substituting these values into the box-counting definiton, we get:

\begin{align*}
\text{dim}_BF &= \lim_{\frac{1}{\delta} \to 0} \frac{\ln(\delta^2)}{-\ln(\frac{1}{\delta})}\\
&= \lim_{\frac{1}{\delta} \to 0} \frac{\ln(\delta^2)}{\ln(\delta)}\\
&= \lim_{\frac{1}{\delta} \to 0} 2\frac{\ln(\delta)}{\ln(\delta)}\\
&= 2
\end{align*}

Which is expected, becuase we know that a square is a 2-Dimensional shape. We
can apply this same concept to fractals. Consider another example, the Koch
Curve, a self similar fractal which we can calculate its dimension and provide a
measure of roughness of the curve. If we take a close look at the curve progression
in figure [[koch-line]], the pattern begins with one line segment and the middle third
of the line is replaced with two sides of an equilateral triangle with side length
$\frac{1}{3}$. After this first iteration, the line segment now becomes four line
segments. Thus, if we use a square of length $\frac{1}{3^{\delta}}$ to cover the $\delta^{th}$
iteration of the curve, there will be $4^{\delta}$ line segments covered.

Let $F$ be the Koch Curve.
\begin{align*}
\text{dim}_BF &= \lim_{\frac{1}{3^{\delta}} \to 0} \frac{\ln(4^{\delta})}{-\ln(\frac{1}{3^{\delta}})}\\
&= \lim_{\frac{1}{3^{\delta}} \to 0} \frac{\ln(4^{\delta})}{\ln(3^{\delta})}\\
&= \lim_{\frac{1}{3^{\delta}} \to 0} \frac{\ln(4)}{\ln(3)}\\
&= \frac{\ln(4)}{\ln(3)}
\end{align*}
** Generating Self Similar Fractals                                            :Ryan:
In order to investigate the dimension of fractals, we intend to generate and measure a variety of figures by using of */R/* cite:rcoreteamLanguageEnvironmentStatistical2020, /Julia/ cite:bezansonJuliaFreshApproach2017 and /Python/ cite:WelcomePythonOrg.

Self Similar fractals have a self-similar dimension and so can be used to verify an approach implemented with a programming language.

*** Vicsek Fractal
:PROPERTIES:
:CUSTOM_ID: vicsek-fractal
:END:



The Vicsek Fractal [[cite:vicsekFractalGrowthPhenomena1992][p. 12]] involves a pattern of iterating boxes, to implement this consider the process[fn:: This was actually a fractal I came up with myself only to later find that somebody already had the same idea!]:



\begin{align}
\mathbf{B} \leftarrow
   \begin{bmatrix}
       \mathbf{B} & \mathbf{Z} & \mathbf{B} \\
       \mathbf{Z} & \mathbf{B} & \mathbf{Z} \\
       \mathbf{B} & \mathbf{Z} & \mathbf{B} \\
   \end{bmatrix} \label{eq:visek-iter}
\end{align}

where:

- \(\mathbf{B}= \left[ 1 \right]\)
- \(\mathbf{Z}= \left[ 0 \right]  \)


If this is repeated many times a matrix of values will be created, such a matrix
can be interpreted as a greyscale image and plotted as a heatmap to show the
fractal (shown in figure [[vicsek-fratal-julia]]).


# #+ATTR_LATEX: :float wrap :width 0.38\textwidth :placement{r}{0.4\textwidth}
#+attr_html: :width 300px
#+ATTR_LATEX: :float wrap :width 0.38\textwidth
#+NAME: vicsek-fractal-julia
#+CAPTION: Vicsek fractal [[cite:vicsekFractalGrowthPhenomena1992][p. 12]] (also known as the /AntiCross-Stictch/ cite:janwassenaarCantorDust2005) produced by listing [[vicsek-matrix-gen]], at each iterative step the fractal itself is "copied" to the four corners of itself producing this complex shape.
[[file:media/Vicsek-Fractal.png]]


The iterative process shown in eqref:eq:visek-iter is represented as a recursive function at line 5 of listing [[vicsek-matrix-gen]] and plotted immediately after. To measure the the dimension of this fractal a the sum of the matrix is taken to be the measure of the fractal, two fractals are generated and the change in size relative to the scale is compared and the log taken to return the value of the dimension:

\[
\mathcal{D} = \frac{s}{m_{2}/m_{1}}
\]

The recursive function begins with a 3x3 matrix, where the four corner squares
and middle square are set to 1 and the rest are set to 0, a new matrix is built
by joining together the past matrix following the rule described in eqref:eq:visek-iter.
The function repeats until it reaches some arbitrary set width.


At each step of the process, the number of elements of this fractal increases by
a ratio of 5 while the height increases only by a factor of 3, hence the self
similarity dimension is given by:


\begin{align}
5 &= 3^{\mathcal{D}} \nonumber \\
\implies \mathcal{D} &= \frac{\ln 5}{\ln 3} \label{eq:vic-dim-val}
\end{align}





#+NAME: vicsek-matrix-gen
#+CAPTION: Generating the Vicsek Fractal (shown in figure ref:vicsek-fractal-julia) and measuring the dimension using /Julia/, the measured dimension is consistent with the self similarity dimension shown in eqref:eq:vic-dim-val
#+begin_src julia
#------------------------------------------------------------
#--- Function -----------------------------------------------
#------------------------------------------------------------
function visek_matrix(ICMat, width)
    B = ICMat
    h  = size(B)[1]
    w  = size(B)[2]
    Z  = zeros(Int, h, w)
    B = [B Z B ;
         Z B Z ;
          B Z B]
    if (3*w)<width
        B = visek_matrix(B, width)
    end
    return B
end

#------------------------------------------------------------
#-- Plot ----------------------------------------------------
#------------------------------------------------------------
(mat = visek_matrix(fill(1, 1, 1), 27)) |> size
GR.imshow(mat)

#------------------------------------------------------------
#-- Similarity Dimension ------------------------------------
#------------------------------------------------------------

mat2  = visek_matrix(fill(1, 1, 1), 1000)
l2    = sum(mat2)
size2 = size(mat2)[1]

mat1  = visek_matrix(fill(1, 1, 1), 500)
l1    = sum(mat1)
size1 = size(mat1)[1]

#------------------------------------------------------------
julia> log(l2/l1)/log(size2/size1)
1.4649735207179269
julia> log(5)/log(3)
1.4649735207179269
#+end_src

By modifying listing [[vicsek-matrix-gen]] alternative fractals can get also be generated like /Cantor's Dust/ and /Sierpinski's Carpet/ shown in figures [[fig:cantor-dust]] and [[fig:sierpinski-carpet]].

Upon review this is actually a variant on the /Cantor Dust/ which should
actually be represented by a \(3 \times 3\) matrix:

\begin{align}
 \mathbf{B} \leftarrow
 \begin{bmatrix}
    \mathbf{B} & \mathbf{Z} & \mathbf{B} \\
    \mathbf{Z} & \mathbf{Z} & \mathbf{Z} \\
    \mathbf{B} & \mathbf{Z} & \mathbf{B} \\
\end{bmatrix}
\end{align}


and hence has the same dimension as the /Vicsek Fractal/ as opposed to a
dimension of 1.

**** Sierpinskis Carpet and Cantor's Dust
By modifying the approach provided in listing [[vicsek-matrix-gen]] other fractals
such as /Sierpinski's Carpet/ and /Cantor's Dust/ can be produced, this is
implemented in listings [[l-s-carpet]] [[l-cant-dust]] and shown in figures
[[fig:square-carpet]] and [[fig:cantor-dust]] respectively. [fn:spc]

[fn:spc] See generally Ch. 2.7 of [[cite:peitgenChaosFractalsNew2004][\S 2.7]] for further Reading.


[fn:spc] See generally Ch. 2.7 of [[cite:peitgenChaosFractalsNew2004][\S 2.7]] for further Reading.

#+NAME: l-s-carpet
#+CAPTION: Function to produce Sierpinski's carpet, shown in figure [[fig:square-carpet]]
#+begin_src julia
#------------------------------------------------------------
#--- Function -----------------------------------------------
#------------------------------------------------------------

function dust(ICMat, width)
    B = ICMat
    h  = size(B)[1]
    w  = size(B)[2]
    Z  = zeros(Int, h, w)
    B = [B B B;
         B Z B;
         B B B]
    if (3*w)<width
        B = dust(B, width)
    end
    return B
end

#------------------------------------------------------------
#-- Plot ----------------------------------------------------
#------------------------------------------------------------
using GR, Plots
gr() # Set Plots backend as GR

(mat = dust(fill(1, 1, 1), 9^2)) |> size
p1 = GR.imshow(mat)

#------------------------------------------------------------
#-- Dimension -----------------------------------------------
#------------------------------------------------------------
mat2 = dust(fill(1, 1, 1), 1000)
l2   = sum(mat2)
size2 = size(mat2)[1]
mat1 = dust(fill(1, 1, 1), 500)
l1   = sum(mat1)
size1 = size(mat1)[1]

#------------------------------------------------------------
## julia> log(l2/l1)/log(size2/size1)
## 1.89
#+end_src


#+NAME: fig:square-carpet
#+CAPTION: Sierpinksi's Carpet, produced by listing [[listing l-s-carpet]].
#+attr_html: :width 400px
#+attr_latex: :width 7cm
[[file:media/sierpinsky_carpet.png]]


#+attr_html: :width 300px
#+attr_latex: :width 7cm
#+NAME: fig:cantor-dust
#+CAPTION: A shape this is similar, but different to, the /Cantor Dust/, the dimension of this fractal is 1, produced by listing [[l-cant-dust]].
[[file:media/Cantor_Dust_gen.png]]


#+NAME: l-cant-dust
#+CAPTION: Function to generate Cantor Dust, shown in [[fig:cantor-dust]]
#+begin_src julia
#------------------------------------------------------------
#--- Function -----------------------------------------------
#------------------------------------------------------------

function dust(ICMat, width)
    B = ICMat
    h  = size(B)[1]
    w  = size(B)[2]
    Z  = zeros(Int, h, w)
    B = [Z Z B Z;
         B Z Z Z;
         Z Z Z B;
         Z B Z Z]
    if (3*w)<width
        B = dust(B, width)
    end
    return B
end

#------------------------------------------------------------
#-- Plot ----------------------------------------------------
#------------------------------------------------------------
using GR, Plots
gr() # Set Plots backend as GR

(mat = dust(fill(1, 1, 1), 9^2)) |> size
p1 = GR.imshow(mat)


#------------------------------------------------------------
#-- Dimension -----------------------------------------------
#------------------------------------------------------------
mat2 = dust(fill(1, 1, 1), 1000)
l2   = sum(mat2)
size2 = size(mat2)[1]
mat1 = dust(fill(1, 1, 1), 500)
l1   = sum(mat1)
size1 = size(mat1)[1]

#------------------------------------------------------------
## julia> log(l2/l1)/log(size2/size1)
## 1.0

#+end_src


**** Sierpinski's Triangle
Not all fractal patterns can be produced by using recursive functions involving matrices, one such function is /Sierpinskis Triangle/.
***** Chaos Game
The chaos game is a technique that can generate fractals, one of the advantages of this approach is that it can provide an estimate of the theoretical measure of a fractal without needing to iterate a function many times. The technique involves marking 3 points of an equilateral triangle and marking an arbitrary point, select one of these 3 points randomly with a uniform probability and create a new point halfway between the previous point and this point, repeat this process for as many points of detail are desired for the image.

This can be visualised by mapping the co-ordinates of an equilateral triangle to a cartesian plane:

- \(A\)  \(\left(0, 0\right)\)
- \(B\)  \(\left(0, 1\right)\)
- \(C\)  \(\left(0.5, \sin\left(\frac{\pi}{3}\right)\right)\)

The mean value of the \(x\), \(y\) values for these co-ordinates is equal to the
halfway point and using this the chaos game can be implemented as a program and
visualised by plotting each point on a scatter plot. This is implemented in
/*R*/ in listing [[l-sier-tri]] and the output is shown in figure [[fig:s-tri]].

To measure the fractal dimension of this could be done by mapping the cartesian
plane back to a matrix and taking the same approach as previous fractals
presented, this however was not implemented, due to time constraints, the
dimension was however measured using the method discussed at \S [[#pas-tri]].

#+NAME: l-sier-tri
#+CAPTION: R code to construct Sierpinksi's triangle through the Choas Game, shown in figure [[fig:s-tri]].
#+BEGIN_SRC R :exports both :results output graphics file :file pascal-sierpinsky-chaos-game.png :eval never-export
library(ggplot2)
# Parameters
n <- 50000
df <- data.frame("xval"=1:n, "yval"=1:n)
# Constants
x <- c(runif(1), runif(1))
A <- c(0, 0)
B <- c(1, 0)
C <- c(0.5, sin(pi/3))
# Loop
for (i in 1:n) {
    dice = sample(1:3, 1)
    if (dice == 1) {
        x <- (x + A)/2
        df[i,] <- x
    } else if (dice == 2) {
        x <- (x + B)/2
        df[i,] <- x
    } else {
        x <- (x + C)/2
        df[i,] <- x
    }
}
# Plot
ggplot(df, aes(x = xval, y = yval)) +
    geom_point(size = 1, col = "cadet blue") +
    theme_classic()

#+END_SRC

#+NAME: fig:s-tri
#+CAPTION: Sierpinski's Triangle created using the /Chaos Game/ in listing [[l-sier-tri]].
#+attr_html: :width 400px
#+attr_latex: :width 3cm :float wrap
[[file:pascal-sierpinsky-chaos-game.png]]

***** TODO Pascals Triange                                                  :Ryan:
:PROPERTIES:
:CUSTOM_ID: pas-tri
:END:

The even and odd values in /Pascal's Triangle/ demonstrate the same pattern as
the /Sierpinski Triangle/ this is discussed in greater detail in \S
[[#pascal-sierpinski]], implementing this to produce the sierpinski triangle is very
simple, it is however significantly more resource intensive, even in /Julia/
than using the chaos game and the the measured dimension converges to the self
similar dimension very slowly.

The fractal produced is composed of right angle triangles, as opposed to equilateral triangles but interestingly the measured dimension is still the same as an equlateral /Sierpinski's Triangle/, it does however converge to this value slowly.

@@latex: \newpage @@
#+NAME: pascal-triangle-sierpinski
#+CAPTION: Julia code demonstrating Sierpinksi's triangle, this converges to the self similar dimension very slowly, using the ratio between a \(3000^{2}\) and \(2000^{2}\) matrix gave the correct answer to 2 decimal places, using a \(300^{2}\) and \(200^{2}\) matrix produced a value far of as shown.
#+begin_src julia
function pascal(n)
    mat = [isodd(binomial(BigInt(j+i),BigInt(i))) for i in 0:n, j in 0:n]
    return mat
end
GR.imshow(pascal(999))
GR.savefig("../../Report/media/pascal-sierpinsky-triangle.png")

#------------------------------------------------------------
#-- Calculate Dimension -------------------------------------
#------------------------------------------------------------

mat2 = pascal(300)
l2   = sum(mat2)
size2 = size(mat2)[1]
mat1 = pascal(200)
l1   = sum(mat1)
size1 = size(mat1)[1]
log(l2/l1)/log(size2/size1)
# https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle
log(3)/log(2)

#------------------------------------------------------------
julia> log(l2/l1)/log(size2/size1)
1.8177195595512954
julia> log(3)/log(2)
1.5849625007211563


#+end_src

#+RESULTS: pascal-triangle-sierpinski

#+attr_html: :width 300px
#+attr_latex: :width 9cm
#+NAME: fig:pascal-sierpinsky
#+CAPTION: Sierpinski's triangle generated
[[file:media/pascal-sierpinsky-triangle.png]]
*** Turtle

#+attr_html: :width 600px
#+NAME: snow-turtle
#+CAPTION: Portion of the Koch Snowflake Produced by the Turtle graphics in listing [[turtle-snow]]
#+ATTR_LATEX: :float wrap :width 0.25\textwidth :placement {r}{0.4\textwidth}
[[file:../Problems/Chaos/Spirals/snowCurve.png]]


Some Fractals cannot be well explained by using matrices or the chaos game, Turtle graphics are a programatic way to draw a pen across a screen, these are implemented in /Julia/ using the /Luxor/ package cite:JuliaGraphicsLuxorJl2020.



We were unfourtunately unable to implement a strategy to measure the dimension
of such fractals, one such approach that looked promising but did not return
consistent results was to export the generated image to a PNG and then import
that file as a matrix using the /Python Pillow Library/ cite:PillowPillowPIL or
the /Julia Images/ library cite:JuliaImagesImagesJl2020, when this was
unsucessful we also experimented with /ImageMagick/ cite:llcImageMagick,
/AstroPy/ cite:Astropy and /JuliaAstro/ cite:JuliaAstroJuliaAstro.
Unfourtunately the values returned by this approach were inconsistent and
further investigation into this method is required.

The koch snowflake can be implemented by recursively calling a function that draws the first level of a koch curve, if this function decrements a provided level and is defined to call itself for each arm of the curve unless the level has reached zero it will produce a koch snowflake at the specified level, this is shown in figure [[snow-turtle]] and can be implemented in julia like so:

# #+NAME: turtle-snow
# #+CAPTION: Generate a Koch Snowflake using a Turtle Diagram
#+begin_src julia
using Shapefile
using Luxor
using Pkg

#------------------------------------------------------------
#--- Round Snowflake Working ---------------------------------
#------------------------------------------------------------
function snowflake(length, level, ♘)
    if level == 0
        Forward(♘, length)
        Circle(♘, 1)
        return
    end
    length = length/9
    snowflake(length, level-1, ♘)
    Turn(♘, -60)
    snowflake(length, level-1, ♘)
    Turn(♘, 2*60)
    snowflake(length, level-1, ♘)
    Turn(♘, -60)
    snowflake(length, level-1, ♘)
end

♘ = Turtle()
@png begin
for i in 1:3
    levels = 9
    Pendown(♘)
    snowflake(8^(levels-1), levels, ♘)
    Turn(♘, 120)
end
end 600 600 "snowCurve.png"

#+end_src

The dragon curve is slightly more complicated and can be implemented by two seperate functions, one to turn and trigger a motion and the other to control in which direction to turn, this is shown in figure [[dragon-turtle]] and implemented by the following /Julia/ code:

#+begin_src julia
using Shapefile
using Luxor

#------------------------------------------------------------
#--- Dragon -------------------------------------------------
#------------------------------------------------------------
# Define the Parent Function
function dragon(♘, order, length)
    print(" ") # Don't remove this or code breaks, I don't know why?
    Turn(♘, order*45)
    dragon_iterate(♘, order, length, 1)
end
# Define the Helper Function
function dragon_iterate(♘, order, length, sign)
    if order==0
        Forward(♘, length)
    else
        rootHalf = sqrt(0.5)
        dragon_iterate(♘, order -1, length*rootHalf, 1)
        Turn(♘, sign * -90)
        dragon_iterate(♘, order -1, length*rootHalf, -1)
    end
end
# Draw the Image
@png begin
    ♘ = Turtle()
    # Start from left to centre result
    Turn(♘, 180)
    Penup(♘)
    Forward(♘, 200)
    Pendown(♘)
    Turn(♘, 180)
    # Create the Output
    dragon(♘, 15, 400)
end 1000 1000

# Create many images
;mkdir /tmp/dragon
for i in range(1, 15)
name = string("/tmp/dragon/d", lpad(d, 5, "0"), ".png")
    @png begin
        ♘ = Turtle()
        # Start from left to centre result
        Turn(♘, 180)
        Penup(♘)
        Forward(♘, 200)
        Pendown(♘)
        Turn(♘, 180)
        # Create the Output
        dragon(♘, 15, 400)
    end 1000 1000 name
end
montage -geometry 1000x1000 *.png dragon.png

#+end_src



#+attr_html: :width 600px
#+attr_latex: :width 9cm
#+NAME: dragon-turtle
#+CAPTION: Progression of the Dragon Curve, this is known as a space filling curve [[cite:peitgenChaosFractalsNew2004][p. 350]] which is a curve with a range that contains the entire 2-dimensional unit square cite:ventrellaSpaceFillingCurvesAre2014, it has a dimension of two. For some historical background on the curve on the origins of this curve see cite:tabachnikovDragonCurvesRevisited2014.
[[file:../Problems/Chaos/Spirals/dragon.png]]





@@latex: \newpage @@
*** Pascals Triangle and Sierpinski's Triangle                                :James:
:PROPERTIES:
:CUSTOM_ID: pascal-sierpinski
:END:
**** Motivation
Over many centuries, mathematicians have been able to produce a range of patterns from Pascal's triangle. One of which is relevant to the emergence of Sierpinski's triangle. To construct Pascal's triangle it begins with a 1 in the $0^{th}$ (top) row, then each row underneath is made up of the sum of the numbers directly above it, see figure [[fig:pascal-triangle]]. Alternatively, the $n^{th}$ row and $k^{th}$ column can be written in combinatorics form, $\binom{n}{k} = \binom{n-1}{k-1} + \binom{n-1}{k}$.

#+attr_html: :width 300px
#+att_latex: :width 9cm :height 9cm
#+NAME: fig:pascal-triangle
#+CAPTION: Pascal's triangle
[[file:media/tikz/pascals-triangle.png]]
**** The connection
As mentioned before there is one pattern that produces the Sierpinski triangle, namely highlighting all odd numbers in Pascal's triangle. This is equivalent to considering all the numbers in the triangle modulo 2, shown in figure [[fig:pascal-sierpinski-tri]].

#+attr_html: :width 300px
#+attr_latex: :width 9cm
#+NAME: fig:pascal-sierpinski-tri
#+CAPTION:
[[file:media/tikz/pascal-sierpinski-tri.png]]

#+attr_html: :width 300px
#+attr_latex: :width 9cm
#+NAME: fig:row-column-pascal
#+CAPTION: The black squares represent one example of a position on Pascal's triangle that are equivalent modulo 2
[[file:media/tikz/row-column-pascal.png]]

In figure [[fig:pascal-sierpinski-tri]], we can observe that all the highlighted odd numbers begin to form the Sierpinski triangle. Note that this is not the complete Sierpinski's triangle, that would require an infinite number of iterations. Now, we also notice that there are three identical Sierpinski triangles within the larger triangle, each containing the same value modulo 2, at each corresponding row and column.

To prove this, we need to split the triangle into two parts, $P_{n}$ denoting the first $2^{n}$ rows, i.e. the top "Sierpinski triangle" in figure [[fig:pascal-sierpinski-tri]] and $P_{n+1}$ representing the entire triangle. We must show that any chosen square in $P_{n}$ is equal to the corresponding row and column in the lower two triangles of $P_{n+1}$, shown in figure [[fig:row-column-pascal]]. This requires an identity that allows us to work with combinations in modulo 2, namely Lucas' Theorem.

*Lucas' Theorem*
Let $n,k \ge 0$ and for some prime $p$, we get:
\begin{equation}
\binom{n}{k} = \prod_{i=0}^{m} \binom{n_i}{k_i} \quad (\text{mod}~p)
\end{equation}
where,
\begin{align*}
n &= n_{m}p^{m}+n_{m-1}p^{m-1}+\cdots + n_{1}p+n_{0},\\
k &= k_{m}p^{m}+k_{m-1}p^{m-1}+\cdots + k_{1}p+k_{0}\\
\end{align*}
are the expansions in radix $p$ [fn:: Radix refers to a numerical system which uses some number of digits. Since we are working in modulo 2 for Pascal's triangle, we are only concerned with the numbers $0$ or $1$, i.e. a radix 2 or a binary numeric system.]. This uses the convention that $\binom{n}{k} = 0$ if $k < n$

Take some arbitrary row $r$ and column $c$ in the triangle $P_{n}$. If we add $2^{n}$ rows to $r$, we will reach the equivalent row and column in the lower left triangle of $P_{n+1}$, since there are $2^{n}$ rows in $P_{n}$. In the same way, if we add $2^{n}$ columns to $c$ we reach the equivalent row and column in the lower right triangle of $P_{n+1}$, leaving us with:

\begin{align*}
\text{Top Triangle:} \quad &\binom{r}{c}  \\
\text{Bottom-left Triangle:}\quad &\binom{r + 2^n}{c}  \\
\text{Bottom-right Triangle :}\quad &\binom{r + 2^n}{c + 2^n} \label{eq:bottom-right}
\end{align*}

Using Lucas' theorem, we can prove that the above statments are equivalent.

We can rewrite $r$ and $c$ in base 2 notation as follows:
\begin{align*}
r=r_{i}2^{i}+r_{i-1}2^{i-1}+\cdots + r_{1}2+r_{0}= \left[r_{i}r_{i-1}\cdots r_{1}r_{0}\right]_2\\
c=c_{i}2^{i}+c_{i-1}2^{i-1}+\cdots +c_{1}2+c_{0}=\left[c_{i}c_{i-1}\cdots c_{1}c_{0}\right]_2\\
\end{align*}

\begin{align*}
\binom{2^n + r}{c}~(\text{mod}~2) &= \binom{1r_{i-1}r_{i-2} \cdots r_{0}}{0c_{i-1}c_{i-2} \cdots c_{0}} \quad (\text{mod} 2)\\
&= \binom{1}{0}\binom{r_{i-1}}{c_{i-1}}\binom{r_{i-2}}{c_{i-2}} \cdots \binom{r_0}{c_0} \quad (\text{mod} 2)\\
&=\binom{r_{i-1}}{c_{i-1}}\binom{r_{i-2}}{c_{i-2}} \cdots \binom{r_0}{c_0} \quad (\text{mod} 2)\\
&= \binom{r}{c} \quad (\text{mod} 2)
\end{align*}

\begin{align*}
\binom{2^n + r}{2^n + c}~(\text{mod}~2) &= \binom{1r_{i-1}r_{i-2} \cdots r_{0}}{1c_{i-1}c_{i-2} \cdots c_{0}} \quad (\text{mod} 2)\\
&= \binom{1}{1}\binom{r_{i-1}}{c_{i-1}}\binom{r_{i-2}}{c_{i-2}} \cdots \binom{r_0}{c_0} \quad (\text{mod} 2)\\
&=\binom{r_{i-1}}{c_{i-1}}\binom{r_{i-2}}{c_{i-2}} \cdots \binom{r_0}{c_0} \quad (\text{mod} 2)\\
&= \binom{r}{c} \quad (\text{mod} 2)
\end{align*}

Thus, $\binom{r}{c} = \binom{2^n + r}{c} = \binom{2^n + r}{2^n + c} \quad (\text{mod} 2)$, which concludes the proof

** TODO Fractal Dimensions Sans Self Similarity                                :Ryan:
*** STRT Calculating the Dimension of Julia Sets
:PROPERTIES:
:ID:       ee034972-1d74-446d-be67-d47dbb843700
:CUSTOM_ID: jl-set-dim
:END:
A value on the complex plane can be associated with the julia set by iterating
that value against a function of the form $z \rightarrow z^{2} + \alpha + i
\beta$ and measuring whether or not that value diverges or converges. This
process is demonstrated in listing [[ref:jsetDivFunc]].

By associating each value on the complex plane with an element of a matrix an image of this pattern may be produced, by considering only values on the boundary between convervgent and divergent an outline may be produced see for example figure [[fig:julia-rab]], this outline is known as the /Julia Set/.

In order to measure the dimension of the /Julia Set/ it is necessary to generate
a representation of the fractal at two scales, compare them and then and then
measure the corresponding dimension value as was done previously. The julia set
is a non self-similar fractal and so it is not immediately clear whether or not
the dimension will be constant at all scales, to determine whether or not the
dimension is constant at various scales it can be convenient to plot the log
transformed scaling factor and measures and inspect whether or not the points
form a linear relationship, the slope of such a relationship will be the
dimension [[cite:vicsekFractalGrowthPhenomena1992][p. 30]].

To implement this all the functions necessary to build the fractals were placed into a seperate script ~julia-set-functions.jl~ which is shown in \S [[julia-set-functions-script]] and this script was included into a working script ~julia-set-dimensions.jl~ by using the following line:

#+begin_src julia
@time include("./Julia-Set-Dimensions-functions.jl")
#+end_src


The julia set is defined as the boundary between values on the complex plane that converge and diferge under iteration of \(z\leftarrow z^{2} + a+ib\) to consider only the boundary of values, the ~juliaSet~ function shown in  listing [[jsetDivFunc]] can be modified to return only the value of 1 or 0 as opposed to the time taken to cross the threshold of divergence [fn:: \(\mathtt{abs}\left(z\right) \) exceeds to the point is assured to diverge under iteration] and then it can be determined whether or not a point is a boundary by considering whether or not the sum of all elements within the immediate neighbourhood of the elemnt is greater than 1. This is shown in the ~outline~ function which is defined in \S [[#julia-set-functions-script]].

Comparing squared values rather than using ~abs()~ improved the performance of this function by about two fold.

#+NAME: fig:julia-rab
#+CAPTION: Image of the Doudy Rabbit, the julia set corresponding to the iteration of \(z \leftarrow z^{2} -0.123+0.745i\) produced by /Julia/
#+attr_html: :width 400px
#+attr_latex: :width 12cm
[[file:media/outline-rabbit.png]]


#+NAME: jsetDivFunc
#+CAPTION: Function that returns how many iterations of a function of is necessary for a complex value to diverge, the julia set is concerned with the function $z \rightarrow z^{2} + \alpha + i \beta$
#+begin_src julia
#!/bin/julia
function juliaSet(z, num, my_func, boolQ=true)
    count = 1
    # Iterate num times
    while count ≤ num
        # check for divergence
        if real(z)^2+imag(z)^2 > 2^2
            if(boolQ) return 0 else return Int(count) end
        end
        #iterate z
        z = my_func(z) # + z
        count=count+1
    end
        #if z hasn't diverged by the end
    if(boolQ) return 1 else return Int(count) end
end
#+end_src


So I run the code shown in listing [[dimensions-julia-set]] which calls a file ~./Julia-Set-Dimensions-functions.jl~ which is shown in \S [[#julia-set-functions-script]]

which returs the values shown in table [[table-of-values]].

#+NAME: dimensions-julia-set
#+CAPTIONS: Functions used by listing [[dimensions-julia-set]]
#+begin_src julia
@time include("./Julia-Set-Dimensions-functions.jl")

############################################################
#### Investigate Plot #######################################
############################################################
test_mat = make_picture(800,800, z -> z^2 + -0.123+0.745*im)

#Inspect
GR.imshow(test_mat) # PyPlot uses interpolation = "None"
# Outline
test_mat = outline(test_mat)
#Inspect
GR.imshow(test_mat) # PyPlot uses interpolation = "None"
# GR.savefig("/home/ryan/Dropbox/Studies/2020Spring/QuantProject/Current/Python-Quant/Problems/fractal-dimensions/media/outline-Julia-set.png")

## Return the perimeter
sum(test_mat)


# Take a measurement at a point

mat2 = outline(make_picture(9000,9000, f))
l2   = sum(mat2)
size2 = size(mat2)[1]
mat1 = outline(make_picture(10000,10000, f))
l1   = sum(mat1)
size1 = size(mat1)[1]
log(l2/l1)/log(size2/size1)
# https://en.wikipedia.org/wiki/Vicsek_fractal#Construction
# 1.3934 Douady Rabbit
#

# Take a measurement using LInear Regression
using CSV

@time data=scaleAndMeasure(900, 1000 , 4, f)
# CSV.read("./julia-set-dimensions.csv", data)
# data = CSV.read("./julia-set-dimensions.csv")
data.scale = [log(i) for i in data.scale]
data.mass  = [log(i) for i in data.mass]
mod   = lm(@formula(mass ~ scale), data)
p = Gadfly.plot(data, x=:scale, y=:mass, Geom.point)

print("the slope is $(round(coef(mod)[2], sigdigits=4))")
print(mod)
print("\n")
return mod

a = SharedArray{Float64}(10)
@distributed for i = 1:10
    a[i] = i
end

#------------------------------------------------------------
julia> return mod
StatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}

mass ~ 0 + scale

Coefficients:
────────────────────────────────────────────────────────────────────
         Coef.   Std. Error        t  Pr(>|t|)  Lower 95%  Upper 95%
────────────────────────────────────────────────────────────────────
scale  1.28358  0.000497296  2581.11     <1e-9    1.28199    1.28516
────────────────────────────────────────────────────────────────────

#+end_src


This converges very slowly and the code can take a very long time to run, and has a tendency to cause crashes, likely due to the large amounts of memory required, these are things that could be improved, by running this code for scales from 9000 to 10000 and leaving it for an hour, the following table of values is returned:

| scale |    mass |
|-------+---------|
|   500 |  4834.0 |
|   563 |  5754.0 |
|   625 |  6640.0 |
|   688 |  7584.0 |
|   750 |  8418.0 |
|   813 |  9550.0 |
|   875 | 10554.0 |
|   938 | 11710.0 |
|  1000 | 12744.0 |

Linear Regression can be performed against these values using */R/* [fn:: The could just as well have been done inside Julia]

#+begin_src R
scale   <- c(500, 563, 625, 688, 750, 813, 875, 938, 1000)
measure <- c(  4834, 5754, 6640, 7584, 8418, 9550, 10554, 11710, 12744)
data <- data.frame(scale, measure)

lm(log(measure) ~ 0 + log(scale), data)$coefficients # set 0 intercept

#------------------------------------------------------------
# 1.36720041333112
#+end_src

#+RESULTS[f3a76eddf73e1b71f01c46663f47f497147342d6]:
: 1.36720041333112

This shows that the value returned is 1.37 which is very close to the value provided by Wikipedia at 1.39, inspecting the behaviour ofthe log transformed scale and measure indicates that there is a very linear relationship between these variables.

#+BEGIN_SRC R :exports both :results output graphics file :file media/r-ggplot-linear-reg-julia.png
library(ggplot2)
ggplot(data, aes(x = log(measure), y = log(scale))) +
  geom_point(size = 6, col = 'red') +
  geom_smooth(method = 'lm') +
  theme_bw() +
  labs(x = "log Measure", y = "log Scale",
       title = "Comparison of Scale and Measure of Julia Set", subtitle = "Douady Rabbit")
#+end_src

#+RESULTS[1c407fac73de0d24ebddcf0874b6cf8d3531b064]:
[[file:media/r-ggplot-linear-reg-julia.png]]

**** Functions Julia Set
:PROPERTIES:
:CUSTOM_ID: julia-set-functions-script
:END:

The following functions were saved in a file called ~@time include("./Julia-Set-Dimensions-functions.jl")~, this file was loaded into the current workspace by using ~@time include("./Julia-Set-Dimensions-functions.jl")~ at the top of a script.

#+begin_src julia
using GR
using DataFrames
using Gadfly
using GLM
using SharedArrays
using Distributed

############################################################
### Julia / MandelBrot Functions ###########################
############################################################

"""
# Julia Set
Returns how many iterations it takes for a value on the complex plane to diverge
under recursion. if `boolQ` is specified as true a 1/0 will be returned to
indicate divergence or convergence.

## Variables
- `z`
  - A value on the complex plane within the unit circle
- `num`
  - A number of iterations to perform before conceding that the value is not
    divergent.
- `my_func`
  - A function to perform on `z`, for a julia set the function will be of the
    form `z -> z^2 + a + im*b`
    - So for example the Douady Rabbit would be described by `z -> z^2 -0.123+0.745*im`
"""
function juliaSet(z, num, my_func, boolQ=true)
    count = 1
    # Define z1 as z
    z1 = z
    # Iterate num times
    while count ≤ num
        # check for divergence
        if real(z1)^2+imag(z1)^2 > 2^2
            if(boolQ) return 0 else return Int(count) end
        end
        #iterate z
        z1 = my_func(z1) # + z
        count=count+1
    end
        #if z hasn't diverged by the end
    if(boolQ) return 1 else return Int(count) end
end


"""
# Mandelbrot Set
Returns how many iterations it takes for a value on the complex plane to diverge
under recursion of \$z \\rightarrow z^2 + z_0\$.

Values that converge represent constants of the julia set that lead to a
connected set. (TODO: Have I got that Vice Versa?)


## Variables
- `z`
  - A value on the complex plane within the unit circle
- `num`
  - A number of iterations to perform before conceding that the value is not
    divergent.
- `boolQ`
  - `true` or `false` value indicating whether or not to return 1/0 values
    indicating divergence or convergence respecitvely or to return the number of
   iterations performed before conceding no divergence.
"""
function mandelbrot(z, num, boolQ = true)
    count = 1
    # Define z1 as z
    z1 = z
    # Iterate num times
    while count ≤ num
        # check for divergence
        if real(z1)^2+imag(z1)^2 > 2^2
            if(boolQ) return 0 else return Int(count) end
        end
        #iterate z
        z1 = z1^2 + z
        count=count+1
    end
        #if z hasn't diverged by the end
    return 1 # Int(num)
    if(boolQ) return 1 else return Int(count) end
end

function test(x, y)
    if(x<1) return x else return y end
end


############################################################
##### Build a Matrix Image #################################
############################################################

"""
# Make a Picture

This maps a function on the complex plane to a matrix where each element of the
matrix corresponds to a single value on the complex plane. The matrix can be
interpreted as a greyscale image.

Inside the function is a `zoom` parameter that can be modified for different
fractals, fur the julia and mandelbrot sets this shouldn't need to be adjusted.

The height and width should be interpreted as resolution of the image.

- `width`
  - width of the output matrix
- `height`
  - height of the output matrix
- `myfunc`
  - Complex Function to apply across the complex plane
"""
function make_picture(width, height, my_func)
    pic_mat = zeros(width, height)
    zoom = 0.3
    for j in 1:size(pic_mat)[2]
        for i in 1:size(pic_mat)[1]
            x = (j-width/2)/(width*zoom)
            y = (i-height/2)/(height*zoom)
            pic_mat[i,j] = juliaSet(x+y*im, 256, my_func)
        end
    end
    return pic_mat
end

############################################################
### Make the Outline ########################################
############################################################

"""
# Outline

Sets all elements with neighbours on all sides to 0.

- `mat`
  - A matrix
    - If this matrix is the convergent values corresponding to a julia set the
      output will be the outline, which is the definition of the julia set.
"""
function outline(mat)
    work_mat = copy(mat)
    for col in 2:(size(mat)[2]-1)
        for row in 2:(size(mat)[1]-1)
            ## Make the inside 0, we only want the outline
            neighbourhood = mat[row-1:row+1,col-1:col+1]
            if sum(neighbourhood) >= 9 # 9 squares
                work_mat[row,col] = 0
            end
        end
    end
    return work_mat
end


############################################################
###### Return many Scaled Values ###########################
############################################################



function scaleAndMeasure(min, max, n, func)
    # The scale is equivalent to the resolution, the initial resolution could be
    # set as 10, 93, 72 or 1, it's arbitrary (previously I had res and scale)
    # #TODO: Prove this

    scale = [Int(ceil(i)) for i in range(min, max, length=n) ]
    mass = pmap(s -> sum(outline(make_picture(Int(s), Int(s), func))) , scale)

    data = DataFrame(scale = scale, mass = mass)
    return data
end

#+end_src

* Connecting Fractals to Natural Processes                                      :Ryan:
:PROPERTIES:
:CUSTOM_ID: my-fractal
:END:
My fractal really shows many unique patterns

If it is scaled by $\varphi$ then the boxes increase two fold.

We know the dimension will be constant because the figure is self similar, so we have:

\[
\mathrm{dim} (\mathtt{my\_fractal}) = \log_{\varphi}=\frac{\log \varphi}{\log 2}
\]
** Graphics

#+attr_html: :width 60px
#+attr_latex: :width 9cm
#+NAME: My-Frac-GR
#+CAPTION: TODO
[[file:../Problems/fractal-dimensions/scale-of-my-fractal.svg]]

#+attr_html: :width 60px
#+attr_latex: :width 9cm
#+NAME: My-Frac-GR
#+CAPTION: TODO
[[file:../Problems/fractal-dimensions/my-self-rep-frac.svg]]

#+attr_html: :width 60px
#+attr_latex: :width 9cm
#+NAME: My-Frac-GR
#+CAPTION: TODO
[[file:../Problems/fractal-dimensions/golden-angle-diagram.svg]]

#+attr_html: :width 60px
#+attr_latex: :width 9cm
#+NAME: My-Frac-GR
#+CAPTION: TODO
[[file:../Problems/fractal-dimensions/my-self-rep-frac-ink-diagram.svg]]

#+attr_html: :width 60px
#+attr_latex: :width 9cm
#+NAME: My-Frac-GR
#+CAPTION: TODO
[[file:../Problems/fractal-dimensions/My-Self-Replicating-fractal-ink.svg]]

#+attr_html: :width 600px
#+attr_latex: :width 9cm
#+NAME: My-Frac-GR
#+CAPTION: Fractal that emerges by Rotating and appending boxes, this demonstrates the relationship between the Fibonacci numbers and golden ratio very well
[[file:../Problems/fractal-dimensions/my-self-rep-frac-GR.png]]

#+attr_html: :width 200px
#+attr_latex: :width 9cm
#+NAME: My-Frac-GR
#+CAPTION: Fractal that emerges by Rotating and appending boxes, this demonstrates the relationship between the Fibonacci numbers and golden ratio very well
[[file:../Problems/fractal-dimensions/My-Fib-Fractal-Diagram.svg]]

** Discuss Pattern shows Fibonacci Numbers
*** HOLD Angle Relates to Golden Ratio
** HOLD Prove Fibonacci using Monotone Convergence Theorem
Consider the series:

$$\begin{aligned}
G_n &= \frac{F_{n} }{F_{n - 1} } \\
\end{aligned}$$

Such that:

$$\begin{aligned}
F_n = F_{n- 1} +  F_{n- 2} ; \quad F_1 = F_2 = 1
\end{aligned}$$


*** HOLD Show that the Series is Monotone
$$\begin{aligned}
F_{n} &> 0 \\
0 &< F_{n} \\
 \implies   0 &< F_{n - 2} +  F_{n- 1} \quad \forall n > 2 \\
  F_{n- 2} &< F_{n- 1}  \\
   \implies  F_n & < F_{n+1}
\end{aligned}$$

$$\begin{aligned}
F_{n} &> 0 \\
0 &< F_{n} \\
 \implies   0 &< F_{n - 2} +  F_{n- 1} \quad \forall n > 2 \\
  F_{n- 2} &< F_{n- 1}  \\
   \implies  F_n & < F_{n+1}
\end{aligned}$$



*** HOLD Show that the Series is Bounded
*** HOLD Find the Limit
$$\begin{aligned}
G &= \frac{F_{n} +  F_{n+  1} }{F_{n+  1} } \\
&= 1 +  \frac{F_{n- 1} }{F_n} \\
\text{Recall that $F_n > 0 \forall n$}\\
&=  1 +  \frac{1}{    \left\lvert G \right\rvert } \\
 \implies  0 &= G^2- G +  1; \quad G > 0  \\
  \implies  G = \varphi &=  \frac{\sqrt{5} - 1  }{2} \quad  \square
\end{aligned}$$


*** HOLD Comments

The Fibonacci sequence is quite unique, observe that:

This can be rearranged to show that the Fibonacci sequence is itself
when shifted in either direction, it is the sequence that does not
change during recursion.

\[\begin{aligned}
F_{n+ 1} - F_{n} = F_{n- 1} \quad \forall n > 1
\end{aligned}\]

This is analogous to how $e^x$ doesn't change under differentiation:

$$\begin{aligned}
\frac{\mathrm{d} }{\mathrm{d} x}\left( e^x \right) \ldots
\end{aligned}$$

or how 0 is the additive identity and it shows why generating functions
are so useful.

Observe also that

$$\begin{aligned}
\lim_{n     \rightarrow \infty }\left[ \frac{F_n}{F_{n- 1} }  \right] &= \varphi \\
\lim_{n     \rightarrow \infty }\left[ \frac{F_n}{F_{n- 1} }  \right] &= \psi \\
\varphi - \psi &=  1 \\
\varphi \times  \psi  &= 1 \\
\frac{\psi}{\varphi}  = \frac{1}{\varphi^2} = \frac{1}{1-\varphi} &= \frac{1}{2-\varphi} = \frac{2}{3 - \sqrt{5}  }
\end{aligned}$$
*** HOLD Python

#+BEGIN_SRC python :exports both :results output graphics file :eval never-export :file ./a.png
,#+begin_src python
import matplotlib.pyplot as plt
import sympy

plt.plot([ sympy.N(sympy.fibonacci(n+1)/sympy.fibonacci(n)) for n in range(1, 30)])
plt.savefig("./a.png")
#+end_src
[[file:./a.png]]

** Angle is $\tan^{-1}\left( \frac{1}{1-\varphi}\right)$
*** Similar to Golden Angle $2 \pi \left( \frac{1}{1-\varphi}\right)$
** Dimension of my Fractal
$\log_{\varphi}(2)$
** Code should be split up or put into appendix
#+begin_src julia
function matJoin(A, B)
    function nrow(X)
        return size(X)[1]
    end
    function ncol(X)
        return size(X)[2]
    end
    emptymat = zeros(Bool, max(size(A)[1], size(B)[1]) ,sum(ncol(A) + ncol(B)) )
    emptymat[1:nrow(A), 1:ncol(A)] = A
    emptymat[1:nrow(B), (ncol(A)+1):ncol(emptymat)] = B
    return emptymat
end

function mywalk(B, n)
    for i in 1:n
        B = matJoin(B, rotl90(B));
    end
    return B
end

############################################################
##### Use Plot for themes ##################################
############################################################

using Plots
# SavePlot
## Docstring
    """
# MakePlot
Saveplot will save a plot of the fractals

- `n`
  - Is the number of iterations to produce the fractal
    - ``\\frac{n!}{k!(n - k)!} = \\binom{n}{k}``
- `filename`
  - Is the File name
- `backend`
  - either `gr()` or `pyplot()`
    - Gr is faster
    - pyplot has lines
    - Avoiding this entirely and using `GR.image()` and
     `GR.savefig` is even faster but there is no support
     for changing the colour schemes

    """
function makePlot(n, backend=pyplot())
    backend
    plt = Plots.plot(mywalk([1 1], n),
                     st=:heatmap, clim=(0,1),
                     color=:coolwarm,
                    colorbar_title="", ticks = true, legend = false, yflip = true, fmt = :svg)
    return plt
end
plt = makePlot(5)

"""
# savePlot
Saves a Plot created with `Plots.jl` to disk (regardless of backend) as both an
svg, use ImageMagick to get a PNG if necessary

- `filename`
  - Location on disk to save image
- `plt`
  - A Plot object created by using `Plot.jl`
"""
function savePlot(filename, plt)
    filename = replace(filename, " " => "_")
    path = string(filename, ".svg")
    Plots.savefig(plt, path)
    print("Image saved to ", path)
end

#------------------------------------------------------------
#-- Dimension -----------------------------------------------
#------------------------------------------------------------
# Each time it iterates the image scales by phi
# and the number of pixels increases by 2
# so log(2)/log(1.618)
# lim(F_n/F_n-1)
# but the overall dimensions of the square increases by a factor of 3
# so 3^D=5 ==> log_3(5) = log(5)/log(3) = D
using DataFrames
function returnDim()
    mat2 = mywalk(fill(1, 1, 1), 10)
    l2   = sum(mat2)
    size2 = size(mat2)[1]
    mat1 = mywalk(fill(1, 1, 1), 11)
    l1   = sum(mat1)
    size1 = size(mat1)[1]
    df = DataFrame
    df.measure = [log(l2/l1)/log(size2/size1)]
    df.actual  = [log(2)/log(1.618) ]
    return df
end

############################################################
### Main Functions ##########################################
############################################################
# Usually Main should go into a seperate .jl filename
# Then a compination of import, using, include will
# get the desired effect of top down programming.
# Combine this with using a tmp.jl and tst.jl and you're set.
# See https://stackoverflow.com/a/24935352/12843551
# http://ryansnotes.org/mediawiki/index.php/Workflow_Tips_in_Julia

# Produce and Save a Plot
#=
filename = "my-self-rep-frac";
filename = string(pwd(), "/", filename);
savePlot(filename, makePlot(5))
;convert $filename.svg $filename.png
makePlot(5, pyplot())
=#
# Return the Dimensions
returnDim()


############################################################
#### Render Image ##########################################
#################yellow and purple##########################
using GR
GR.imshow(mywalk([1 1], 5))


#+end_src

* TODO The Fibonacci Sequence
The Fibonacci Sequence occurs in my example from the \S [[#my-fractal]], let's investigate it
** Introduction                                                                :Ryan:
The /Fibonacci Sequence/ and /Golden Ratio/ share a deep connection[fn:fb] and occur in patterns observed in nature very frequently
(see
cite:shellyallenFibonacciNature,benedettapalazzoNumbersNatureFibonacci2016,MinarovaNikoletta2014TFSN,NatureGoldenRatio2018,robertlambHowAreFibonacci2008,ronknottFibonacciNumbersGolden2016), an example of such an occurence is discussed in section [[#sunflower-example]].


In this section we lay out a strategy to find an analytic solution to the
/Fibonacci Sequence/ by relating it to a continuous series and generalise this
approach to any homogenous linear recurrence relation.

This details some open mathematical work for the project and our hope is that by
identifying relationships between discrete and continuous systems generall we
will be able to draw insights with regard to the occurrence of patterns related
to the /Fibonacci Sequence/ and /Golden Ratio/ in nature.

** HOLD Computational Approach                                                 :Ryan:
   :PROPERTIES:
   :CUSTOM_ID: define-the-fibonacci-numbers
   :END:
Given that much of our work will involve computational analysis and simulation we begin with a strategy to solve the sequence computationally.

The /Fibonacci/ Numbers are given by:

\begin{align}
F_n = F_{n-1} + F_{n-2} \label{eq:fib-def}
\end{align}

This type of recursive relation can be expressed in /Python/ by using recursion,
as shown in listing [[fib-rec-0]], however using this function will reveal that it
is extraordinarily slow, as shown in listing [[time-slow]], this is because the
results of the function are not cached and every time the function is called
every value is recalculated[fn:cch], meaning that the workload scales in
exponential as opposed to polynomial time.

The ~functools~ library for python includes the ~@functools.lru_cache~ decorator
which will modify a defined function to cache results in memory
cite:FunctoolsHigherorderFunctions, this means that the recursive function will
only need to calculate each result once and it will hence scale in polynomial
time, this is implemented in listing [[fib-cache]].


#+NAME: fib-rec-0
#+CAPTION: Defining the /Fibonacci Sequence/ eqref:eq:fib-def using Recursion
#+BEGIN_SRC python
  def rec_fib(k):
      if type(k) is not int:
          print("Error: Require integer values")
          return 0
      elif k == 0:
          return 0
      elif k <= 2:
          return 1
      return rec_fib(k-1) + rec_fib(k-2)
#+END_SRC

#+NAME: time-slow
#+CAPTION: Using the function from listing [[fib-rec-0]] is quite slow.
#+BEGIN_SRC python
  start = time.time()
  rec_fib(35)
  print(str(round(time.time() - start, 3)) + "seconds")

## 2.245seconds
#+END_SRC


#+NAME: fib-cache
#+CAPTION: Caching the results of the function previously defined [[time-slow]]
#+BEGIN_SRC python
  from functools import lru_cache

  @lru_cache(maxsize=9999)
  def rec_fib(k):
      if type(k) is not int:
          print("Error: Require Integer Values")
          return 0
      elif k == 0:
          return 0
      elif k <= 2:
          return 1
      return rec_fib(k-1) + rec_fib(k-2)


start = time.time()
rec_fib(35)
print(str(round(time.time() - start, 3)) + "seconds")
## 0.0seconds
#+END_SRC

#+BEGIN_SRC python
  start = time.time()
  rec_fib(6000)
  print(str(round(time.time() - start, 9)) + "seconds")

## 8.3923e-05seconds
#+END_SRC

Restructuring the problem to use iteration will allow for even greater performance as demonstrated by finding $F_{10^{6}}$ in listing [[fib-iter]]. Using a compiled language such as /Julia/ however would be thousands of times faster still, as demonstrated in listing [[julia-fib]].



#+NAME: fib-iter
#+CAPTION: Using Iteration to Solve the Fibonacci Sequence
#+BEGIN_SRC python
  def my_it_fib(k):
      if k == 0:
          return k
      elif type(k) is not int:
          print("ERROR: Integer Required")
          return 0
      # Hence k must be a positive integer

      i  = 1
      n1 = 1
      n2 = 1

      # if k <=2:
      #     return 1

      while i < k:
         no = n1
         n1 = n2
         n2 = no + n2
         i = i + 1
      return (n1)

  start = time.time()
  my_it_fib(10**6)
  print(str(round(time.time() - start, 9)) + "seconds")

 ## 6.975890398seconds
#+END_SRC

#+NAME: julia-fib
#+CAPTION: Using Julia with an iterative approach to solve the 1 millionth fibonacci number
#+begin_src julia :results output
function my_it_fib(k)
    if k == 0
        return k
    elseif typeof(k) != Int
        print("ERROR: Integer Required")
        return 0
    end
    # Hence k must be a positive integer

    i  = 1
    n1 = 1
    n2 = 1

    # if k <=2:
    #     return 1
    while i < k
       no = n1
       n1 = n2
       n2 = no + n2
       i = i + 1
    end
    return (n1)
end

@time my_it_fib(10^6)

##  my_it_fib (generic function with 1 method)
##    0.000450 seconds
#+end_src

In this case however an analytic solution can be found by relating discrete
mathematical problems to continuous ones as discussed below at section [[#exp-gen-function]].
** Exponential Generating Functions
:PROPERTIES:
:CUSTOM_ID: exp-gen-func-fib-seq
:END:
**** Motivation                                                              :Ryan:
    :PROPERTIES:
    :CUSTOM_ID: motivation
    :END:

Consider the /Fibonacci Sequence/ from eqref:eq:fib-def:


\begin{align}
    a_{n}&= a_{n - 1} + a_{n - 2} \nonumber \\
\iff a_{n+  2} &= a_{n+  1} +  a_n \label{eq:fib-def-shift}
\end{align}


from observation, this appears similar in structure to the following /ordinary
differential equation/, which would be fairly easy to deal with:


\begin{align*}
f''\left( x \right)- f'\left( x \right)- f\left( x \right)=  0
\end{align*}

By ODE Theory we have $y \propto e^{m_{i}x}, \enspace i = 1, 2$:

\begin{align*}
f\left( x \right)= e^{mx} = \sum^{\infty}_{n= 0}   \left[ r^{m} \frac{x^n}{n!} \right]
\end{align*}

So using some sort of a transformation involving a power series may help to
relate the discrete problem back to a continuous one.

**** Example                                                                 :Ryan:
    :PROPERTIES:
    :CUSTOM_ID: solving-the-sequence
    :END:

Consider using the following generating function, (proof of the
generating function derivative as in eqref:eq:exp-gen-def-2 and eqref:eq:exp-gen-def-3 is
provided in section [[#Derivative-exp-gen-function]])




\begin{align}
    f\left( x \right) &=  \sum^{\infty}_{n= 0}   \left[ a_{n} \cdot  \frac{x^n}{n!} \right]   \label{eq:exp-gen-def-1} \\
 \implies   f'\left( x \right) &=  \sum^{\infty}_{n= 0}   \left[ a_{n+1} \cdot  \frac{x^n}{n!} \right]   \label{eq:exp-gen-def-2} \\
\implies    f''\left( x \right) &=  \sum^{\infty}_{n= 0}   \left[ a_{n+2} \cdot  \frac{x^n}{n!} \right]   \label{eq:exp-gen-def-3}
\end{align}


So the Fibonacci recursive relation from eqref:eq:fib-def-shift  could be expressed :


\begin{align*}
a_{n+  2}    &= a_{n+  1} +  a_{n}\\
\frac{x^n}{n!}   a_{n+  2}    &= \frac{x^n}{n!}\left( a_{n+  1} +  a_{n}  \right)\\
\sum^{\infty}_{n= 0} \left[ \frac{x^n}{n!}   a_{n+  2} \right]        &= \sum^{\infty}_{n= 0}   \left[ \frac{x^n}{n!} a_{n+  1} \right]  + \sum^{\infty}_{n= 0}   \left[ \frac{x^n}{n!} a_{n}  \right]  \\
\end{align*}

And hence by applying eqref:eq:exp-gen-def-1, eqref:eq:exp-gen-def-2 and eqref:eq:exp-gen-def-3:

\begin{align}
f''\left( x \right) &= f'\left( x \right)+  f\left( x \right)
\end{align}


Using the theory of higher order linear differential equations with
constant coefficients it can be shown:


\begin{align*}
f\left( x \right)= c_1 \cdot  \mathrm{exp}\left[ \left( \frac{1- \sqrt{5} }{2} \right)x \right] +  c_2 \cdot  \mathrm{exp}\left[ \left( \frac{1 +  \sqrt{5} }{2} \right)x \right]
\end{align*}


By equating this to the power series:


\begin{align*}
f\left( x \right)&= \sum^{\infty}_{n= 0}   \left[ \left( c_1\left( \frac{1- \sqrt{5} }{2} \right)^n +  c_2  \left( \frac{1+ \sqrt{5} }{2} \right)^n \right) \cdot  \frac{x^n}{n!} \right]
\end{align*}


Now given that:


\begin{align*}
f\left( x \right)= \sum^{\infty}_{n= 0}   \left[ a_n \frac{x^n}{n!} \right]
\end{align*}


We can conclude that:


\begin{align*}
a_n = c_1\cdot  \left( \frac{1- \sqrt{5} }{2} \right)^n +  c_2 \cdot  \left( \frac{1+  \sqrt{5} }{2} \right)^n
\end{align*}


By applying the initial conditions:


\begin{align*}
a_0= c_1 +  c_2  \implies  c_1= - c_2\\
a_1= c_1 \left( \frac{1+ \sqrt{5} }{2} \right) -  c_1 \left( \frac{1-\sqrt{5} }{2} \right)  \implies  c_1 = \frac{1}{\sqrt{5} }\\
\therefore ~ c_1 = \frac{1}{\sqrt{5}, ~ c_2 = -\frac{1}{\sqrt{5}}}
\end{align*}


And so finally we have the solution to the /Fibonacci Sequence/ ref:eq:fib-def-shift:


\begin{align}
    a_n &= \frac{1}{\sqrt{5} } \left[ \left( \frac{1+  \sqrt{5} }{2}  \right)^n -  \left( \frac{1- \sqrt{5} }{2} \right)^n \right] \nonumber \\
&= \frac{\varphi^n - \psi^n}{\sqrt{5} } \nonumber\\
&=\frac{\varphi^n -  \psi^n}{\varphi - \psi} \label{eq:fib-sol}
\end{align}


where:

- $\varphi = \frac{1+ \sqrt{5} }{2} \approx 1.61\ldots$
- $\psi = 1-\varphi = \frac{1- \sqrt{5} }{2} \approx 0.61\ldots$

**** Derivative of the Exponential Generating Function
    :PROPERTIES:
    :CUSTOM_ID: Derivative-exp-gen-function
    :END:
***** Base                                                                  :Ryan:
    Differentiating the exponential generating function has the effect of shifting the sequence once to the left: cite:lehmanReadingsMathematicsComputer2010

\begin{align}
    f\left( x \right) &= \sum^{\infty}_{n= 0}   \left[ a_n \frac{x^n}{n!} \right] \label{eq:exp-pow-series} \\
f'\left( x \right) &= \frac{\mathrm{d} }{\mathrm{d} x}\left( \sum^{\infty}_{n= 0}   \left[ a_n \frac{x^n}{n!} \right]  \right) \nonumber \\
&= \frac{\mathrm{d}}{\mathrm{d} x} \left( a_0 \frac{x^0}{0!} +  a_1 \frac{x^1}{1!} +  a_2 \frac{x^2}{2!}+  a_3 \frac{x^3}{3! } +  \ldots \frac{x^k}{k!} \right) \nonumber \\
&= \sum^{\infty}_{n= 0}   \left[ \frac{\mathrm{d} }{\mathrm{d} x}\left( a_n \frac{x^n}{n!} \right) \right] \nonumber \\
&= \sum^{\infty}_{n= 0}   {\left[{ \frac{a_n}{{\left({ n- 1 }\right)!}} } x^{n- 1}  \right]} \nonumber \\
\implies f'(x) &= \sum^{\infty}_{n= 1}   {\left[{ \frac{x^n}{n!}a_{n+  1} }\right]} \label{eq:exp-pow-series-sol}
\end{align}

***** Bridge                                                                :James:
This can be shown for all derivatives by way of induction, for

\begin{align}
f^{(k)}\left(x\right) = \sum_{n=k}^\infty\frac{a_{n+k}\cdot x^n}{n!} \quad \text{for}~k \ge 0
\end{align}

Assume that $f^{(k)}\left(x\right) = \sum_{n=k}^\infty\frac{a_{n+k}\cdot x^n}{n!}$

Using this assumption, prove for the next element $k+1$

We need $f^{(k+1)}(x) = \sum_{n=k+1}^\infty\frac{a_{n+k+1}\cdot x^n}{n!}$

\begin{align*}
    \text{LHS} &= f^{(k+1)}(x)\\
    &= \frac{\mathrm{d}}{\mathrm{d}x}\left(f^{(k)}(x)\right)\\
    &= \frac{\mathrm{d}}{\mathrm{d}x}\left(\sum_{n=k}^\infty\frac{a_{n+k}\cdot x^n}{n!}\right)\quad \text{by assumption}\\
    &= \sum_{n=k}^\infty\frac{a_{n+k}\cdot n\cdot x^{n-1}}{n!}\\
    &= \sum_{n=k}^\infty\frac{a_{n+k}\cdot x^{n-1}}{(n-1)!}\\
    &= \sum_{n=k+1}^\infty\frac{a_{n+k+1}\cdot x^{n}}{n!}\\
    &= \text{RHS}
\end{align*}

Therefore, by mathematical induction $f^{(k)}\left(x\right) = \sum_{n=k}^\infty\frac{a_{n+k}\cdot x^n}{n!} \quad \text{for}~k \ge 0$

Furthermore, if the first derivative of the exponential generating function shown in eqref:eq:exp-pow-series-sol
shifts the sequence across, then every derivative thereafter does so as well.

**** TODO Homogeneous Proof                                                  :Ryan:James:
An equation of the form:

\begin{align}
\sum^{n}_{i=0} \left[ c_{i} \cdot f^{(i)}(x) \right] = 0 \label{eq:hom-ode}
\end{align}

is said to be a homogenous linear ODE: [[cite:zillDifferentialEquations2009a][Ch. 2]]

- Linear :: because the equation is linear with respect to $f(x)$
- Ordinary :: because there are no partial derivatives (e.g. $\frac{\partial }{\partial x}{\left({ f{\left({ x }\right)} }\right)}$  )
- Differential :: because the derivates of the function are concerned
- Homogenous :: because the */RHS/* is 0
  - A non-homogeous equation would have a non-zero RHS

There will be $k$ solutions to a $k^{\mathrm{th}}$ order linear ODE, each may be summed to produce a superposition which will also be a solution to the equation, [[cite:zillDifferentialEquations2009a][Ch. 4]]  this will be considered as the desired complete solution (and this will be shown to be the only solution for the recurrence relation eqref:eq:recurrence-relation-def. These $k$ solutions will be in one of two forms:

1. $f(x)=c_{i} \cdot e^{m_{i}x}$
2. $f(x)=c_{i} \cdot x^{j}\cdot e^{m_{i}x}$

where:

- $\sum^{k}_{i=0}\left[  c_{i}m^{k-i} \right] = 0$
  - This is referred to the characteristic equation of the recurrence relation or ODE cite:levinSolvingRecurrenceRelations2018
- $\exists i,j \in \mathbb{Z}^{+} \cap \left[0,k\right]$
  - These are often referred to as repeated roots cite:levinSolvingRecurrenceRelations2018,zillMatrixExponential2009 with a multiplicity corresponding to the number of repetitions of that root [[cite:nicodemiIntroductionAbstractAlgebra2007][\textsection 3.2]]

***** Unique Roots of Characteristic Equation                               :Ryan:
:PROPERTIES:
:CUSTOM_ID: uniq-roots-recurrence
:END:
****** Example
An example of a recurrence relation with all unique roots is the fibonacci sequence, as described in section [[#solving-the-sequence]].
****** Proof
Consider the linear recurrence relation eqref:eq:recurrence-relation-def:

\begin{align}
\sum^{n}_{i= 0}   \left[ c_i \cdot  a_i \right] = 0, \quad \exists c \in
\mathbb{R}, \enspace \forall i<k\in\mathbb{Z}^+ \nonumber \label{eq:recurrence-relation-def}
\end{align}
This implies:


\begin{align}
    \sum^{\infty}_{n= 0}   \left[ \sum^{k}_{i= 0}   \left[ \frac{x^n}{n!} c_i a_n \right]  \right]  &= 0 \\
    \sum^{\infty}_{n= 0}    \sum^{k}_{i= 0}    \frac{x^n}{n!} c_i a_n    &= 0 \\
        \sum^{k}_{i= 0} c_i \sum^{\infty}_{n= 0}    \frac{x^n}{n!}  a_n    &= 0
\end{align}

By implementing the exponential generating function as shown in
eqref:eq:exp-gen-def-1, this provides:

\begin{align}
   \sum^{k}_{i= 0}   \left[ c_i f^{\left( i \right)}\left( x \right) \right]
\end{align}


Now assume that the solution exists and all roots of the characteristic polynomial are unique (i.e. the solution is of the form $f{\left({ x }\right)} \propto e^{m_i x}: \quad m_i \neq m_j \forall i\neq j$), this implies that  [[cite:zillDifferentialEquations2009a][Ch. 4]] :

\begin{align}
    f{\left({ x }\right)} = \sum^{k}_{i= 0}   {\left[{ k_i e^{m_i x} }\right]}, \quad \exists m,k \in \mathbb{C} \nonumber
\end{align}

This can be re-expressed in terms of the exponential power series, in order to relate the solution of the function $f{\left({ x }\right)}$ back to a solution of the sequence $a_n$, (see section [[#prove-exp-power-series]] for a derivation of the exponential power series *#TODO make section on to prove exponential power series using taylor series expansion if we get time)*:

\begin{align}
    \sum^{k}_{i= 0}   {\left[{ k_i e^{m_i x}  }\right]}  &= \sum^{k}_{i= 0}   {\left[{ k_i \sum^{\infty}_{n= 0}   \frac{{\left({ m_i x }\right)}^n}{n!}  }\right]}  \nonumber \\
							 &= \sum^{k}_{i= 0}  \sum^{\infty}_{n= 0}   k_i m_i^n \frac{x^n}{n!} \nonumber\\
							 &=    \sum^{\infty}_{n= 0} \sum^{k}_{i= 0}   k_i m_i^n \frac{x^n}{n!} \nonumber \\
							 &= \sum^{\infty}_{n= 0} {\left[{ \frac{x^n}{n!}  \sum^{k}_{i=0}   {\left[{ k_im^n_i }\right]}  }\right]}, \quad \exists k_i \in \mathbb{C}, \enspace \forall i \in \mathbb{Z}^+\cap {\left[{ 1, k }\right]}     \label{eq:unique-root-sol-power-series-form}
\end{align}


Recall the definition of the generating function from eqref:eq:exp-gen-def-1, by equating this to eqref:eq:unique-root-sol-power-series-form:

\begin{align}
    f{\left({ x }\right)} &= \sum^{\infty}_{n= 0}   {\left[{  \frac{x^n}{n!} a_n }\right]} \nonumber \\
&= \sum^{\infty}_{n= 0} {\left[{ \frac{x^n}{n!}  \sum^{k}_{i=0}   {\left[{ k_im^n_i }\right]}  }\right]}  \nonumber \\
      \implies  a_n &= \sum^{k}_{n= 0} {\left[{ k_im_i^n }\right]}     \nonumber \\ \nonumber
\square
\end{align}

This can be verified by the fibonacci sequence as shown in section [[#solving-the-sequence]], the solution to the characteristic equation is $m_1 = \varphi, m_2 = {\left({ 1-\varphi }\right)}$ and the corresponding solution to the linear ODE and recursive relation are:

\begin{alignat}{4}
    f{\left({ x }\right)} &= &c_1 e^{\varphi x} +  &c_2 e^{{\left({ 1-\varphi }\right)} x}, \quad &\exists c_1, c_2 \in \mathbb{R} \subset \mathbb{C} \nonumber \\
    \iff  a_n &= &k_1 n^{\varphi} +  &k_2 n^{1- \varphi}, &\exists k_1, k_2 \in \mathbb{R} \subset \mathbb{C} \nonumber
\end{alignat}

***** Repeated Roots of Characteristic Equation                             :Ryan:
:PROPERTIES:
:CUSTOM_ID: rep-roots-recurrence
:END:
****** Example
Consider the following recurrence relation:

\begin{align}
    a_{n+2} -  10a_{n+ 1} +  25a_{n}&= 0 \label{eq:hom-repeated-roots-recurrence} \\
    \implies  \sum^{\infty}_{n= 0}   {\left[{ a_{n+2} \frac{x^n}{n!} }\right]} - 10 \sum^{\infty}_{n= 0}   {\left[{ a_{n+1} \frac{x^n}{n!}    }\right]} + 25 \sum^{\infty}_{n= 0 }   {\left[{  a_{n}\frac{x^n}{n!} }\right]}&= 0 \nonumber
\end{align}

By applying the definition of the exponential generating function at eqref:eq:exp-gen-def-1 :

\begin{align}
    f''{\left({ x }\right)}- 10f'{\left({ x }\right)}+  25f{\left({ x }\right)}= 0 \label{eq:rep-roots-func-ode}
\end{align}

By implementing the already well-established theory of linear ODE's, the
characteristic equation for eqref:eq:rep-roots-func-ode can be expressed as:

\begin{align}
    m^2- 10m+  25 = 0 \nonumber \\
    {\left({ m- 5 }\right)}^2 = 0 \nonumber \\
    m= 5 \label{eq:rep-roots-recurrence-char-sol}
\end{align}

Herein lies a complexity, in order to solve this, the solution produced from eqref:eq:rep-roots-recurrence-char-sol can be used with the /Reduction of Order/ technique to produce a solution that will be of the form [[cite:zillMatrixExponential2009][\textsection 4.3]].

\begin{align}
    f{\left({ x }\right)}= c_1e^{5x} +  c_2 x e^{5x} \label{eq:rep-roots-ode-sol}
\end{align}

eqref:eq:rep-roots-ode-sol can be expressed in terms of the exponential power series in order to try and relate the solution for the function back to the generating function,
observe however the following power series identity (proof in section [[#prove-general-exp-identity]]):

\begin{align}
    x^ke^x &= \sum^{\infty}_{n= k}   {\left[{ \frac{x^n}{{\left({ n- k }\right)}!} }\right]}, \quad \exists k \in \mathbb{Z}^+ \label{eq:uniq-roots-pow-series-ident}
\end{align}

by applying identity eqref:eq:uniq-roots-pow-series-ident to equation eqref:eq:rep-roots-ode-sol

\begin{align}
    \implies  f{\left({ x }\right)} &= \sum^{\infty}_{n= 0}   {\left[{ c_1 \frac{{\left({ 5x }\right)}^n}{n!} }\right]}  +  \sum^{\infty}_{n= 1}   {\left[{ c_2 n \frac{{\left({ 5x }\right)^n}}{n{\left({ n-1 }\right)}!} }\right]} \nonumber \\
 &= \sum^{\infty}_{n= 0}   {\left[{ \frac{x^n}{n!} {\left({ c_{1}5^n +  c_2 n 5^n   }\right)} }\right]} \nonumber
\end{align}

Given the defenition of the exponential generating function from eqref:eq:exp-gen-def-1

\begin{align}
    f{\left({ x }\right)}&=     \sum^{\infty}_{n= 0}   {\left[{ a_n \frac{x^n}{n!} }\right]} \nonumber \\
    \iff a_n &= c_{1}5^n +  c_{2}5^n \nonumber \\ \nonumber
    \ \nonumber \\
    \square \nonumber
\end{align}

****** Proof
Consider a recurrence relation of the form:

\begin{align}
     \sum^{k}_{n= 0}   {\left[{ c_i a_n }\right]}  = 0 \nonumber \\
      \implies  \sum^{\infty}_{n= 0}   \sum^{k}_{i= 0}   c_i a_n \frac{x^n}{n!} = 0 \nonumber \\
      \sum^{k}_{i= 0}   \sum^{\infty}_{n= 0}   c_i a_n \frac{x^n}{n!} \nonumber
\end{align}

By substituting for the value of the generating function from eqref:eq:exp-gen-def-1:

\begin{align}
    \sum^{k}_{i= 0}   {\left[{ c_if^{{\left({ k }\right)}}  {\left({ x }\right)}    }\right]} \label{eq:gen-form-rep-roots-ode}
\end{align}

Assume that eqref:eq:gen-form-rep-roots-ode corresponds to a charecteristic polynomial with only 1 root of multiplicity $k$, the solution would hence be of the form:

\begin{align}
			 & \sum^{k}_{i= 0}   {\left[{ c_i m^i }\right]} = 0 \wedge m=B, \enspace  \exists! B \in \mathbb{C} \nonumber \\
 \implies      f{\left({ x }\right)}&= \sum^{k}_{i= 0}   {\left[{ x^i A_i e^{mx} }\right]}, \quad \exists A \in \mathbb{C}^+, \enspace \forall i \in {\left[{ 1,k }\right]} \cap \mathbb{N}  \label{eq:sol-rep-roots-ode}
\end{align}

If we assume the identity from eqref:eq:uniq-roots-pow-series-ident:

\begin{align}
x^k e^x = \sum^{\infty}_{n= k} {\left[{ \frac{x^n}{{\left({ n- k }\right)}!} }\right]}  \nonumber
\end{align}

See section [[#prove-general-exp-identity]] for proof.

We can apply identity eqref:eq:uniq-roots-pow-series-ident to eqref:eq:sol-rep-roots-ode, which gives:

\begin{align}
f{\left({ x }\right)}&=     \sum^{k}_{i= 0}   {\left[{ A_i \sum^{\infty}_{n= i}   {\left[{ \frac{{\left({ x m }\right)}^n}{{\left({ n- i }\right)}!} }\right]}  }\right]} \nonumber \\
&=     \sum^{\infty}_{n= 0}   {\left[{ \sum^{k}_{i=0} {\left[{ \frac{x^n}{n!}  \frac{n!}{{\left({ n- i }\right)!}} A_i m^n }\right]}       }\right]} \nonumber \\
&=     \sum^{\infty}_{n= 0} {\left[{ \frac{x^n}{n!}   \sum^{k}_{i=0} {\left[{  \frac{n!}{{\left({ n- i }\right)!}} A_i m^n }\right]}       }\right]} \nonumber
\end{align}

Recall the generating function that was used to get eqref:eq:gen-form-rep-roots-ode:

\begin{align}
f{\left({ x }\right)}&= \sum^{\infty}_{n= 0}   {\left[{ a_n \frac{x^n}{n!} }\right]}      \nonumber \\
 \implies  a_n &= \sum^{k}_{i= 0}   {\left[{ A_i \frac{n!}{{\left({ n- i }\right)}!} m^n  }\right]} \nonumber \\
 &= \sum^{k}_{i= 0}   {\left[{ m^n A_i \prod_{0}^{k} {\left[{ n- {\left({ i- 1 }\right)} }\right]}   }\right]}
& \intertext{$\because \enspace i \leq k$} \notag \nonumber \\
 &= \sum^{k}_{i= 0} {\left[{ A_i^* m^n n^i }\right]}, \quad \exists A_i \in \mathbb{C}, \enspace \forall i\leq k \in \mathbb{Z}^+ \nonumber \\
\ \nonumber \\
\square \nonumber
\end{align}

****** Proof                                                                :James:
:PROPERTIES:
:CUSTOM_ID: prove-general-exp-identity
:END:
In this section the proof of
******* Motivation

Consider the function $f(x) = xe^x$. Using the taylor series formula we get the following:

\begin{align*}
    xe^x &= 0+\frac{1}{1!}x+\frac{2}{2!}x^2+\frac{3}{3!}x^3+\frac{4}{4!}x^4+\frac{5}{5!}x^5+\dots\\
    &= \sum_{n=0}^\infty \frac{nx^n}{n!}\\
    &= \sum_{n=1}^\infty \frac{x^n}{(n-1)!}
\end{align*}

Similarly, $f(x) = x^2e^x$ will give:
\begin{align*}
    x^2e^x &= \frac{0}{0!} + \frac{0x}{1!} + \frac{2x^2}{2!} + \frac{6x^3}{3!} + \frac{12x^4}{4!} + \frac{20x^5}{5!} + \dots\\
    &= \frac{2\cdot 1x^2}{2!} + \frac{3\cdot 2 x^3}{3!} + \frac{4\cdot 3x^4}{4!} + \frac{5\cdot 4 x^5}{5!} + \dots\\
    &= \sum_{n=2}^\infty \frac{n(n-1)x^n}{n!}\\
    &= \sum_{n=2}^\infty \frac{x^n}{(n-2)!}
\end{align*}

We conjecture thatIf we continue this on, we get:

\begin{align*}
    x^ke^x = \sum_{n=k}^\infty \frac{x^n}{(n-k)!} \quad \text{for}~k\in \mathbb{Z^{+}}\cap0
\end{align*}

***** TODO General Proof
:PROPERTIES:
:CUSTOM_ID: general-gen-func-proof
:END:
In sections [[#uniq-roots-recurrence]] and [[#rep-roots-recurrence]]
it was shown that a recurrence relation can be related to an ODE and then that
solution can be transformed to provide a solution for the recurrence relation.
This was shown in two separate cases, one with unique roots and the other with
repeated roots. However, in many circumstances the solutions to the characteristics
equation are a combination of both unique and repeated roots. Hence, in general the
solution to a linear ODE will be a superposition of solutions for each root, repeated
or unique and so a goal of our research will be to put this together to find a general
solution for homogenous linear recurrence relations.

Sketching out an approach for this:

- Use the Generating function to get an ODE
- The ODE will have a solution that is a combination of the above two forms
- The solution will translate back to a combination of both above forms
****** Power Series Combination
:PROPERTIES:
:CUSTOM_ID: power-series-comb
:END:
** TODO Proving with the Monotone Convergence Theorem                          :Ryan:
By Solving the Fibonacci Sequence using the Monotone Converge Theorem we can show that it is related to \(e\)
** Fibonacci Sequence and the Golden Ratio                                     :Ryan:
:PROPERTIES:
:CUSTOM_ID: fib-golden-ratio-proof
:END:
The /Fibonacci Sequence/ is actually very interesting, observe that the ratios of the terms converge to the /Golden Ratio/:

\begin{align*}
    F_n &= \frac{\varphi^n-\psi^n}{\varphi-\psi} = \frac{\varphi^n-\psi^n}{\sqrt 5} \\
    \iff \frac{F_{n+1}}{F_n}	&= \frac{\varphi^{n+ 1} - \psi^{n+  1}}{\varphi^{n} - \psi^{n}} \\
    \iff \lim_{n \rightarrow \infty}\left[ \frac{F_{n+1}}{F_n} \right]	&= \lim_{n \rightarrow \infty}\left[ \frac{\varphi^{n+ 1} - \psi^{n+  1}}{\varphi^{n} - \psi^{n}} \right] \\
&= \frac{\varphi^{n+ 1} -\lim_{n \rightarrow \infty}\left[ \psi^{n +  1} \right] }{\varphi^{n} - \lim_{n \rightarrow \infty}\left[ \psi^n \right] } \\
\text{because $\mid \psi \mid < 0$ $n \rightarrow \infty \implies \psi^{n} \rightarrow 0$:} \\
&= \frac{\varphi^{n+  1} -  0}{\varphi^{n} -  0} \\
&= \varphi
\end{align*}

We'll come back to this later on when looking at spirals and fractals.

We hope to demonstrate this relationship between the ratio of successive terms
of the fibonacci sequence without relying on ODEs and generating functions and
by instead using limits and the /Monotone Convergence Theorem/, the hope being
that this will reveal deeper underlying relationships between the /Fibonacci
Sequence/, the /Golden Ratio/ and there occurrences in nature (such as the
example in section [[#sunflower-example]] given that the both appear to occur in
patterns observed in nature.

We also hope to find a method to produce the the diagram shown in figure
[[golden-spiral]] computationally, ideally by using the Turtle function in /Julia/.

*** Fibonacci Sequence in Nature (This may be Removed)                        :Ryan:
:PROPERTIES:
:CUSTOM_ID: sunflower-example
:END:
The distribution of sunflower seeds is an example of the /Fibonacci Sequence/
occuring in a pattern observed in nature (see Figure [[sunflower]]).

Imagine that the process a sunflower follows when placing seeds is as follows: [fn:sf]

1. Place a seed
2. Move some small unit away from the origin
3. Rotate some constant angle $\mathtt{\theta}$ (or θ) from the previous seed (with respect to the origin).
4. Repeat this process until a seed hits some outer boundary.

This process can be simulated in Julia cite:bezansonJuliaFreshApproach2017 as shown in listing [[simulate-sunflower]],[fn:un] which combined with /ImageMagick/ (see e.g. [[montage-frac]]), produces output as shown in figure [[simulate-sunflower-image]] and [[simulate-sunflower-phi]].

A distribution of seeds undder this process would be optimal if the amount of empty space was minimised, spirals, stars and swirls contain patterns compromise this.

To minimize this, the proportion of the circle traversed in step 3 must be an
irrational number, however this alone is not sufficent, the decimal values must
also be not to approximated by a rational number, for example
cite:NatureGoldenRatio2018:

+ $\pi \mod 1 \approx \frac{1}{7}=0.7142857142857143$
+ $e \mod 1 \approx \frac{5}{7}= 0.14285714285714285$

It can be seen by simulation that $\phi$ and $\psi$ (because $\phi \mod 1 =
\psi$) are solutions to this optimisation problem as shown in figure
[[simulate-sunflower-phi]], this solution is unstable, a very minor change to the
value will result in patterns re-emerging in the distribution.

Another interesting property is that the number of spirals that appear to rotate
clockwise and anti-clockwise appear to be fibonacci numbers. Connecting this
occure with the relationship between the /Fibonacci Sequence/ as discussed in
section [[#fib-golden-ratio-proof]] is something we hope to look at in this project.
Illustrating this phenomena with /Julia/ by finding the mathematics to colour
the correct spirals is also something we intend to look at in this project.

The bottom right spiral in figure [[simulate-sunflower-image]] has a ratio of rotation of $\frac{1}{\pi}$, the spirals look similar to one direction of the spirals occuring in figure [[simulate-sunflower-phi]], it is not clear if there is any significance to this similarity.

#+NAME: simulate-sunflower
#+CAPTION: Simulation of the distribution of sunflowers as described in section [[#sunflower-example]]
#+begin_src julia :eval never
φ = 1.61803398875
ψ = φ^-1
ψ = 0.61803398875
function sfSeeds(ratio)
♘ = Turtle()
    for θ in [(ratio*2*π)*i for i in 1:3000]
        gsave()
        scale(0.05)
        rotate(θ)
#        Pencolor(♘, rand(1)[1], rand(1)[1], rand(1)[1])
        Forward(♘, 1)
        Rectangle(♘, 50, 50)
        grestore()
    end
    label = string("Ratio = ", round(ratio, digits = 8))
    textcentered(label, 100, 200)
end
@svg begin
    sfSeeds(φ)
end 600 600
#+end_src

#+attr_html: :width 600px
#+attr_latex: :width 9cm
#+NAME: simulate-sunflower-image
#+CAPTION: Simulated Distribution of Sunflower seeds as described in section [[#sunflower-example]] and listing [[simulate-sunflower]]
[[file:media/Outline/sunflower-spirals-montage.png]]

#+attr_html: :width 600px
#+attr_latex: :width 9cm
#+NAME: simulate-sunflower-phi
#+CAPTION: Optimisation of simulated distribution of Sunflower seeds occurs for $\theta =2 \varphi  \pi$ as described in section [[#sunflower-example]] and listing [[simulate-sunflower]]
[[file:media/Outline/golden-flower.svg]]


#+attr_html: :width 600px
#+attr_latex: :width 7cm
#+NAME: sunflower
#+CAPTION: Distribution of the seeds of a sunflower (see cite:simonbrassCCSearch2006 licenced under CC)
[[file:media/Outline/golden-flower.svg]]

** TODO Relating The Fibonacci Sequence to the Julia Set                       :Ryan:
See [[https://youtu.be/ovJcsL7vyrk][this link]].
* Julia Sets                                                                    :Ryan:

The julia set is the outline [[cite:peitgenChaosFractalsNew2004][Ch. 14]].

The mandelbrot has to do with whether or not it's connected.
,** TODO The math behind it
,*** TODO Like Escaping after 2
I cannot figure this out, I need more time, look around Ch. 12 of falconer cite:falconerFractalGeometryMathematical2003
There is a relatioship between the fibonacicci sequence, modelling population growth and the mandelbrot curve, I would like to use that to tie some of the discussion together, see [[https://youtu.be/ovJcsL7vyrk][this video from Veritasium to get an idea of what i mean]].


** Introduction
Julia sets are a very interesting fractal and we hope to investigate them further in this project.
** Motivation
Consider the iterative process $x \rightarrow x^{2}, \enspace x \in \mathbb{R}$,
for values of $x>1$ this process will diverge and for $x<1$ it will converge.

Now Consider the iterative process $z \rightarrow z^{2}, \enspace z \in \mathbb{C}$,
for values of $\left\lvert z \right\rvert >1$ this process will diverge and for $\left\lvert z \right\rvert <1$ it will converge.

Although this seems trivial this can be generalised.

Consider:

- The complex plane for $\left\lvert z \right\rvert \leq 1$
- Some function $f_{c}(z) = z^{2} + c, \quad c \leq 1 \in \mathbb{C}$ that can be used to iterate with

Every value on that plane will belong to one of the two following sets

- $P_{c}$
  + The set of values on the plane that converge to zero (prisoners)
  + Define $Q^{(k)}_{c}$ to be the the set of values confirmed as prisoners after $k$ iterations of $f_{c}$
    - this implies $\lim_{k \rightarrow \infty} \left[ Q^{(k)}_{c}  \right] = P_{c}$
- $E_{c}$
  + The set of values on the plane that tend to $\infty$ (escapees)

In the case of $f_{0}(z) = z^{2}$ all values $\left\lvert z  \right \rvert \leq 1$ are bounded with $\left\lvert z  \right \rvert = 1$ being an unstable stationary circle, but let's investigate what happens for different iterative functions like $f_{1}(z) = z^{2} - 1$, despite how trivial this seems at first glance.

** Plotting the Sets
:PROPERTIES:
:ID:       baa21085-5d8f-4390-9bb7-43c3b51d940d
:END:
Although the convergence of values may appear simple at first, we'll implement a
strategy to plot the prisoner and escape sets on the complex plane.

Because this involves iteration and /Python/ is a little slow, We'll denote
complex values as a vector[fn:vc] and define the operations as described in
listing [[complex-vec]].[fn:ma]

To implement this test we'll consider a function called ~escape_test~ that applies an
iteration (in this case $f_{0}: z \rightarrow z^{2}$) until that value diverges or converges.

While iterating with $f_{c}$ once $\left\lvert z \right\rvert >
\mathrm{max}\left(\left\{c, 2\right\}\right)$, the value must diverge because
\(\left\lvert c \right\rvert \leq 1\), so rather than record whether or not the
value converges or diverges, the ~escape_test~ can instead record the number of
iterations $(k)$ until the value has crossed that boundary and this will provide
a measurement of the rate of divergence.

Then the ~escape_test~ function can be mapped over a matrix, where each element
of that matrix is in turn mapped to a point on the cartesian plane, the resulting matrix
can be visualised as an image [fn:im], this is implemented in listing
[[py-circle-code]] and the corresponding output shown in [[py-circle-plot]].

with respect to listing [[py-circle-code]]:

- Observe that the ~magnitude~ function wasn't used:
   a. This is because a ~sqrt~ is a costly operation and comparing two squares saves an operation



#+NAME: complex-vec
#+CAPTION: Defining Complex Operations with vectors
#+BEGIN_SRC ipython :exports both :results raw :eval never-export :session julia-set :eval never-export
from math import sqrt
def magnitude(z):
    # return sqrt(z[0]**2 + z[1]**2)
    x = z[0]
    y = z[1]
    return sqrt(sum(map(lambda x: x**2, [x, y])))

def cAdd(a, b):
    x = a[0] + b[0]
    y = a[1] + b[1]
    return [x, y]


def cMult(u, v):
    x = u[0]*v[0]-u[1]*v[1]
    y = u[1]*v[0]+u[0]*v[1]
    return [x, y]
#+end_src

#+NAME: py-circle-code
#+CAPTION: Circle of Convergence of $z$ under recursion
#+BEGIN_SRC ipython :exports both :results raw :eval never-export :session julia-set :eval never-export :ipyfile ./circle-of-convergence.svg
%matplotlib inline
%config InlineBackend.figure_format = 'svg'
import numpy as np
def escape_test(z, num):
    ''' runs the process num amount of times and returns the count of
    divergence'''
    c = [0, 0]
    count = 0
    z1 = z  #Remember the original value that we are working with
    # Iterate num times
    while count <= num:
        dist = sum([n**2 for n in z1])
        distc = sum([n**2 for n in c])
        # check for divergence
        if dist > max(2, distc):
            #return the step it diverged on
            return count
        #iterate z
        z1 = cAdd(cMult(z1, z1), c)
        count+=1
        #if z hasn't diverged by the end
    return num



p = 0.25 #horizontal, vertical, pinch (zoom)
res = 200
h = res/2
v = res/2

pic = np.zeros([res, res])
for i in range(pic.shape[0]):
    for j in range(pic.shape[1]):
        x = (j - h)/(p*res)
        y = (i-v)/(p*res)
        z = [x, y]
        col = escape_test(z, 100)
        pic[i, j] = col

import matplotlib.pyplot as plt

plt.axis('off')
plt.imshow(pic)
# plt.show()

#+end_src


#+attr_html: :width 400px
#+attr_latex: :width 9cm
#+NAME: py-circle-plot
#+CAPTION: Circle of Convergence for $f_{0}: z \rightarrow z^{2}$
[[file:media/Outline/circle-of-convergence.svg]]

This is precisely what we expected, but this is where things get interesting,
consider now the result if we apply this same procedure to $f_{1}: z \rightarrow
z^{2} - 1$ or something arbitrary like $f_{\frac{1}{4} + \frac{i}{2}}: z
\rightarrow z^{2} + (\frac{1}{4} + \frac{i}{2})$, the result is something
remarkebly unexpected, as shown in figures [[py-jl-1-plot]] and [[py-jl-rab-plot]].


#+attr_html: :width 400px
#+attr_latex: :width 9cm
#+NAME: py-jl-1-plot
#+CAPTION: Circle of Convergence for $f_{0}: z \rightarrow z^{2} - 1$
[[file:media/Outline/julia-1.svg]]


#+attr_html: :width 400px
#+attr_latex: :width 9cm
#+NAME: py-jl-rab-plot
#+CAPTION: Circle of Convergence for $f_{\frac{1}{4} + \frac{i}{2}}: z \rightarrow z^{2} + \frac{1}{4} + \frac{i}{2}$
[[file:media/Outline/julia-rab.svg]]

To investigate this further consider the
more general function $f_{0.8 e^{\pi i \tau}}: z \rightarrow z^{2} + 0.8 e^{\pi
i \tau}, \enspace \tau \in \mathbb{R}$, many fractals can be generated using
this set by varying the value of $\tau$[fn:wk].

/Python/ is too slow for this, but the /Julia/ programming language, as a
compiled language, is significantly faster and has the benefit of treating
complex numbers as first class citizens, these images can be generated in
/Julia/ in a similar fashion as before, with the specifics shown in listing
[[julia-gen-fracs]]. The ~GR~ package appears to be the best plotting library
performance wise and so was used to save corresponding images to disc, this is
demonstrated in listing [[GR-save]] where 1200 pictures at a 2.25 MP resolution were produced. [fn:tm]

A subset of these images can be combined using /ImageMagick/ and ~bash~ to
create a collage, /ImageMagick/ can also be used to produce an animation but it often
fails and a superior approach is to use ~ffmpeg~, this is demonstrated in
listing [[bash-frac-join]], the collage is shown in figure [[montage-frac]] and a corresponding
animation is [[https://dl.dropboxusercontent.com/s/rbu25urfg8sbwfu/out.gif?dl=0][available online]][fn:ln]].

#+NAME: julia-gen-fracs
#+CAPTION: Produce a series of fractals using julia
#+begin_src julia
# * Define the Julia Set
"""
Determine whether or not a value will converge under iteration
"""
function juliaSet(z, num, my_func)
    count = 1
    # Remember the value of z
    z1 = z
    # Iterate num times
    while count ≤ num
        # check for divergence
        if abs(z1)>2
            return Int(count)
        end
        #iterate z
        z1 = my_func(z1) # + z
        count=count+1
    end
        #if z hasn't diverged by the end
    return Int(num)
end

# * Make a Picture
"""
Loop over a matrix and apply apply the julia-set function to
the corresponding complex value
"""
function make_picture(width, height, my_func)
    pic_mat = zeros(width, height)
    zoom = 0.3
    for i in 1:size(pic_mat)[1]
        for j in 1:size(pic_mat)[2]
            x = (j-width/2)/(width*zoom)
            y = (i-height/2)/(height*zoom)
            pic_mat[i,j] = juliaSet(x+y*im, 256, my_func)
        end
    end
    return pic_mat
end

#+end_src

#+NAME: GR-save
#+CAPTION: Generate and save the images with GR
#+begin_src julia
# * Use GR to Save a Bunch of Images
  ## GR is faster than PyPlot
using GR
function save_images(count, res)
    try
        mkdir("/tmp/gifs")
    catch
    end
    j = 1
    for i in (1:count)/(40*2*π)
        j = j + 1
        GR.imshow(make_picture(res, res, z -> z^2 + 0.8*exp(i*im*9/2))) # PyPlot uses interpolation = "None"
        name = string("/tmp/gifs/j", lpad(j, 5, "0"), ".png")
        GR.savefig(name)
    end
end

save_images(1200, 1500) # Number  and Res
#+end_src

#+NAME: bash-frac-join
#+CAPTION: Using ~bash~, ~ffmpeg~ and /ImageMagick/ to combine the images and produce an animation.
#+begin_src bash
# Use montage multiple times to get recursion for fun
montage (ls *png | sed -n '1p;0~600p') 0a.png
montage (ls *png | sed -n '1p;0~100p') a.png
montage (ls *png | sed -n '1p;0~50p') -geometry 1000x1000  a.png

# Use ImageMagick to Produce a gif (unreliable)
convert -delay 10 *.png 0.gif

# Use FFMpeg to produce a Gif instead
ffmpeg                    \
    -framerate 60         \
    -pattern_type glob    \
    -i '*.png'            \
    -r 15                 \
    out.mov


#+end_src

#+NAME: montage-frac
#+CAPTION: Various fracals corresponding to $f_{0.8 e^{\pi i \tau}}$
#+attr_html: :width 400px
#+attr_latex: :width 0.38\textwidth
[[file:media/Outline/many_julia_fractals_around_circle.png]]

* MandelBrot Set                                                                :Ryan:
:PROPERTIES:
:ID:       c0c790f2-93a7-44f1-9f76-4a20bcd66c62
:DIR:      /home/ryan/Dropbox/Studies/2020Spring/QuantProject/Current/Python-Quant/Outline/
:END:
Investigating these fractals, a natural question might be whether or not any
given $c$ value will produce a fractal that is an open disc or a closed disc.

So pick a value $\left\lvert \gamma \right \rvert < 1$ in the complex plane and
use it to produce the julia set $f_{\gamma}$, if the corresponding prisoner set
$P$ is closed we this value is defined as belonging to the /Mandelbrot/ set.

It can be shown (and I intend to show it generally), that this set is equivalent to re-implementing the previous strategy such that $z \rightarrow z^{2} + z_{0}$ where $z_{0}$ is unchanging or more clearly as a seqeuence:

\begin{align}
z_{n+1} &= z^{2}_n + c \label{eq:mb-sequence} \\
z_{0}   &= c
\end{align}

This strategy is implemented in listing [[mandelbrot-py]] and produces the output shown in figure [[mandelbrot-py-pic]].

#+NAME: py-mandelbrot-code
#+CAPTION: All values of $c$ that lead to a closed /Julia-set/
#+BEGIN_SRC ipython :exports both :results raw :eval never-export :session julia-set :eval never-export :ipyfile ./mandelbrot-py.svg
%matplotlib inline
%config InlineBackend.figure_format = 'svg'
def mandelbrot(z, num):
    ''' runs the process num amount of times and returns the count of
    divergence'''
    count = 0
    # Define z1 as z
    z1 = z
    # Iterate num times
    while count <= num:
        # check for divergence
        if magnitude(z1) > 2.0:
            #return the step it diverged on
            return count
        #iterate z
        z1 = cAdd(cMult(z1, z1),z)
        count+=1
        #if z hasn't diverged by the end
    return num

import numpy as np


p = 0.25 # horizontal, vertical, pinch (zoom)
res = 200
h = res/2
v = res/2

pic = np.zeros([res, res])
for i in range(pic.shape[0]):
    for j in range(pic.shape[1]):
        x = (j - h)/(p*res)
        y = (i-v)/(p*res)
        z = [x, y]
        col = mandelbrot(z, 100)
        pic[i, j] = col

import matplotlib.pyplot as plt
plt.imshow(pic)
# plt.show()
#+end_src

#+attr_html: :width 600px
#+attr_latex: :width 8cm
#+NAME: mandelbrot-py-pic
#+CAPTION: Mandelbrot Set produced in /Python/ as shown in listing [[py-mandelbrot-code]]
#+RESULTS: py-mandelbrot-code
[[file:media/Outline/mandelbrot-py.svg]]

This output although remarkable is however fairly undetailed, by using /Julia/ a much
larger image can be produced, in /Julia/ producing a 4 GB, 400 MP image can be done in little time
(about 10 minutes on my system), this is demonstrated in listing [[julia-large-mandelbrot]]
and the corresponding FITS image is [[https://www.dropbox.com/s/jd5qf1pi2h68f2c/mandelbrot-400mpx.fits?dl=0][available-online.]][fn:ft]

#+NAME:
#+begin_src julia
function mandelbrot(z, num, my_func)
    count = 1
    # Define z1 as z
    z1 = z
    # Iterate num times
    while count ≤ num
        # check for divergence
        if abs(z1)>2
            return Int(count)
        end
        #iterate z
        z1 = my_func(z1) + z
        count=count+1
    end
        #if z hasn't diverged by the end
    return Int(num)
end

function make_picture(width, height, my_func)
    pic_mat = zeros(width, height)
    for i in 1:size(pic_mat)[1]
        for j in 1:size(pic_mat)[2]
            x = j/width
            y = i/height
            pic_mat[i,j] = mandelbrot(x+y*im, 99, my_func)
        end
    end
    return pic_mat
end


using FITSIO
function save_picture(filename, matrix)
    f = FITS(filename, "w");
    # data = reshape(1:100, 5, 20)
    # data = pic_mat
    write(f, matrix)  # Write a new image extension with the data

    data = Dict("col1"=>[1., 2., 3.], "col2"=>[1, 2, 3]);
    write(f, data)  # write a new binary table to a new extension

    close(f)
end

# * Save Picture
#------------------------------------------------------------
my_pic = make_picture(20000, 20000, z -> z^2) 2000^2 is 4 GB
save_picture("/tmp/a.fits", my_pic)

#+end_src

#+attr_html: :width 500px
#+attr_latex: :width 10cm
#+NAME: mandelbrot-screen
#+CAPTION: Screenshot of Mandelbrot FITS image produced by listing [[julia-large-mandelbrot]]
[[file:media/Outline/_20200828_233844screenshot.png]]

* Appendix
:PROPERTIES:
:CUSTOM_ID: appendix
:END:
So unless code contributes directly to the discussion we'll put it in the appendix.
** Finding Material
#+begin_src bash
recoll -c /home/ryan/Dropbox/Books/Textbooks/Mathematics/Chaos_Theory/chaos_books_recoll & disown
#+end_src
** Font Lock
#+begin_src elisp
;; match:
;;; \scite:key\s
(add-to-list 'font-lock-extra-managed-props 'display)
(font-lock-add-keywords nil
 '((" \\(cite:[a-z0-9A-Z]\+\\)" 1 '(face nil display "🤔"))))


;; match
;;; [[cite:key][p. num]]
(add-to-list 'font-lock-extra-managed-props 'display)
(font-lock-add-keywords nil
 '((" \\(\\[\\[cite:[a-z0-9A-Z]\+\\]\\[\.\*\\]\\]\\)" 1 '(face nil display "🤔"))))
#+end_src

#+RESULTS:
| t | (( \(\[\[cite:[a-z0-9A-Z]+\]\[.*\]\]\) 1 '(face nil display 🤔)) ( \(cite:[a-z0-9A-Z]+\) 1 '(face nil display 🤔)) (.*\(\[\[cite:[a-z0-9A-Z]+\]\[.*\]\]\).* 1 '(face nil display 🤔)) (.* \(cite:[a-z0-9A-Z]+\) .* 1 '(face nil display 🤔)) ( \(\[\[cite:[a-z0-9A-Z]+\]\[.*\]\]\)  1 '(face nil display 🤔)) ( \(cite:[a-z0-9A-Z]+\)  1 '(face nil display 🤔)) (org-font-lock-hook) (^\(\**\)\(\* \)\(.* |
** Resources Used for the Hausdorff Dimension
:PROPERTIES:
:CUSTOM_ID: haus-resource
:END:
Research for \S [[#Hausdorff-dimension]] on the Hausdorff Dimension proved actually to be quite difficult, while much information is available online, precice and clear explanations of the Hausdorff dimension are difficult to find without scouring texts, the following proved very helpful generally in preparing for this topic and I would strongly recommend these chapters as a starting point for further reading on this topic:

- Edgar, G. A., /Measure, topology, and fractal geometry/ [[cite:edgarMeasureTopologyFractal2008a][Ch. 6]]
- Falconer, K. J., /Fractal geometry: mathematical foundations and applications/  [[cite:falconerFractalGeometryMathematical2003b][Ch. 2]]
- Gouyet, J., /Physics and fractal structures/ [[cite:gouyetPhysicsFractalStructures1996][\S1.3]]
- Vicsek, T., /Fractal Growth Phenomena/ [[cite:vicsekFractalGrowthPhenomena1992][Ch. 4]]
  + See also p 14 specifically
- Tél, T., Gruiz, M., & Kulacsy, K., /Chaotic dynamics: an introduction based on classical mechanics/  [[cite:telChaoticDynamicsIntroduction2006][\S2.1.2]]
- Peitgen, H., Jürgens, H., & Saupe, D., /Chaos and fractals: new frontiers of science/  [[cite:peitgenChaosFractalsNew2004][\S 4.3]]

* Footnotes


[fn:res]

See \S [[#haus-resource]] for further reading.

[fn:un] Emojis and UTF8 were used in this code, and despite using ~xelatex~ with ~fontspec~ they aren't rendering properly, we intend to have this rectified in time for final submission.

[fn:fb] See section [[#fib-golden-ratio-proof ]]

[fn:nt] The amount of independence that our supervisor afforded us to
investigate other languages is something that we are both extremely grateful for.

[fn:jl] See section [[why-julia]]

[fn:sf]  This process is simply conjecture, other than seeing a very nice example at [[https://www.mathsisfun.com/numbers/nature-golden-ratio-fibonacci.html][/MathIsFun.com/]]
cite:NatureGoldenRatio2018, we have no evidence to suggest that this is the way
that sunflowers distribute there seeds.

However the simulations performed within /Julia/ are very encouraging and
suggest that this process isn't too far off.


[fn:ft] [[https://www.dropbox.com/s/jd5qf1pi2h68f2c/mandelbrot-400mpx.fits?dl=0][https://www.dropbox.com/s/jd5qf1pi2h68f2c/mandelbrot-400mpx.fits?dl=0]]

[fn:tm] On my system this took about 30 minutes.

[fn:ln] [[https://dl.dropboxusercontent.com/s/rbu25urfg8sbwfu/out.gif?dl=0][https://dl.dropboxusercontent.com/s/rbu25urfg8sbwfu/out.gif?dl=0]]

[fn:wk] This approach was inspired by an animation on the /Julia Set/ Wikipedia article cite:JuliaSet2020

[fn:im] these cascading values are much like brightness in Astronomy

[fn:ma] This technique was adapted from Chapter 7 of /Math adventures with Python/ cite:farrellMathAdventuresPython2019

[fn:vc] See figure [[xkcd-im]] for the obligatory /XKCD/ Comic

[fn:cch] Dr. Hazrat mentions something similar in his book with respect to
/Mathematica/\textsuperscript{\textregistered}
[[cite:hazratMathematicaProblemCenteredApproach2015][Ch. 13]]

[fn:op] Although proprietary software such as Magma, Mathematica and Maple is very good, the restrictive licence makes them undesirable for study because there is no means by which to inspect the problem solving tecniques implemented, build on top of the work and moreover the lock-in nature of the software makes it a risky investment with respect to time.
**
