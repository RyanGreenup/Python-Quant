% Created 2020-08-28 Fri 19:56
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\IfFileExists{./resources/style.sty}{\usepackage{./resources/style}}{}
\IfFileExists{./resources/referencing.sty}{\usepackage{./resources/referencing}}{}
\addbibresource{../Resources/references.bib}
\author{Ryan Greenup \& James Guerra}
\date{\today}
\title{Thinking about Problems}
\hypersetup{
 pdfauthor={Ryan Greenup \& James Guerra},
 pdftitle={Thinking about Problems},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.1 (Org mode 9.4)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Submission Outline}
\label{sec:org80f7682}
\subsection{Introduction}
\label{sec:org17b6389}

During preperation for this outline, an article published by the \emph{Mathematical
Association of America} caught my attention, in which mathematics is referred to
as the \emph{Science of Patterns} \cite{friedMathematicsSciencePatterns2010}, this I
feel, frames very well the essence of the research we are looking at in this
project. Mathematics, generally, is primarily concerned with problem solving
(that isn't, however, to say that the problems need to have any
application\footnote{Although Hardy made a good defence of pure math in his 1940s Apology \cite{hardyMathematicianApology2012}, it isn't rare at all for pure math to be found applications, for example much number theory was probably seen as fairly pure before RSA Encryption \cite{spraulHowSoftwareWorks2015}.}), and it's fairly obvious that different strategies work
better for different problems. That's what we want to investigate, Different to
attack a problem, different ways of thinking, different ways of framing
questions.

The central focus of this investigation will be with computer algebra and the
various libraries and packages that exist in the free open source \footnote{Although proprietary software such as Magma, Mathematica and Maple is very good, the restrictive licence makes them undesirable for study because there is no means by which to inspect the problem solving tecniques implemented, build on top of the work and moreover the lock-in nature of the software makes it a risky investment with respect to time.} space to solve
and visualise numeric and symbolic problems, these include:

\begin{itemize}
\item Programming Languages and CAS
\begin{itemize}
\item Julia
\begin{itemize}
\item SymEngine
\end{itemize}
\item Maxima
\begin{itemize}
\item Being the oldest there is probably a lot too learn
\end{itemize}
\item Julia
\item Reduce
\item Xcas/Gias
\item Python
\begin{itemize}
\item Numpy
\item Sympy
\end{itemize}
\end{itemize}
\item Visualisation
\begin{itemize}
\item Makie
\item Plotly
\item GNUPlot
\end{itemize}
\end{itemize}


Many problems that look complex upon initial inspection can be solved trivially
by using computer algebra packages and our interest is in the different
approaches that can be taken to \emph{attack} each problem. Of course however this leads to the question:


\begin{quote}
Can all mathematical problems be solved by some application of some set of rules?
\end{quote}

This is not really a question that we can answer, however, determinism with
respect to systems is appears to make a very good area of investigation with respect to finding ways to deal with problems.

This is not an easy question to answer, however, while investigating this problem



Determinism

Are problems deterministic? can the be broken down into a step by step way? For
example if we \emph{discover all the rules} can we then simply solve all the problems?

chaos to look at patterns generally to get a deeper understanding of patterns
and problems, loops and recursion generally.

To investigate different ways of thinking about math problems our investigation

laplaces demon

but then heisenberg,

but then chaos and meh.

\subsection{Preliminary Problems}
\label{sec:org4155872}
We did a tonne of these but this one really illustrates the sort of things that we're looking at.
\subsubsection{Iteration and Recursion}
\label{series-and-recursion}
To illustrate an example of different ways of thinking about a problem, consider the series shown in \eqref{eq:rec-ser}\footnote{This problem is taken from Project A (44) of Dr. Hazrat's \emph{Mathematica: A Problem Centred Approach} \cite{hazratMathematicaProblemCenteredApproach2015}} :

\begin{align}
    g\left( k \right) &=  \frac{\sqrt{2} }{2} \cdot   \frac{\sqrt{2+  \sqrt{3}}  }{3} \frac{\sqrt{2 +  \sqrt{3 +  \sqrt{4} } } }{4} \cdot  \ldots \frac{\sqrt{2 +  \sqrt{3 +  \ldots +  \sqrt{k} } } }{k} \label{eq:rec-ser}
\end{align}

let's modify this for the sake of discussion:

\begin{align}
h\left( k \right) = \frac{\sqrt{2}  }{2} \cdot  \frac{\sqrt{3 +  \sqrt{2} } }{3} \cdot  \frac{\sqrt{4 +  \sqrt{3 +  \sqrt{2} } } }{4} \cdot  \ldots \cdot  \frac{\sqrt{k +  \sqrt{k - 1 +  \ldots \sqrt{3 + \sqrt{2}  } } } }{k} \label{eq:rec-ser-mod}
\end{align}

The function \(h\) can be expressed by the series:

$$\begin{aligned}
h\left( k \right) = \prod^k_{i = 2} \left( \frac{f_i}{i}  \right)  \quad : \quad f_i = \sqrt{i +  f_{i - 1}}, \enspace f_{1} = 1
\end{aligned}$$

Within \emph{Python}, it isn't difficult to express \(h\), the series can be expressed with recursion as shown in listing \ref{rec-one}, this is a very natural way to define series and sequences and is consistent with familiar mathematical thought and notation. Individuals more familiar with programming than analysis may find it more comfortable to use an iterator as shown in listing \ref{it-one}.

\begin{listing}[htbp]
\begin{minted}[]{python}
################################################################################
from sympy import *
def h(k):
    if k > 2:
        return f(k) * f(k-1)
    else:
        return 1

def f(i):
    expr = 0
    if i > 2:
        return sqrt(i + f(i -1))
    else:
        return 1
\end{minted}
\caption{\label{rec-one}Solving \eqref{eq:rec-ser-mod} using recursion.}
\end{listing}


\begin{listing}[htbp]
\begin{minted}[]{python}
  from sympy import *
  def h(k):
      k = k + 1 # OBOB
      l = [f(i) for i in range(1,k)]
      return prod(l)

  def f(k):
      expr = 0
      for i in range(2, k+2):
          expr = sqrt(i + expr, evaluate=False)
      return expr/(k+1)
\end{minted}
\caption{\label{it-one}Solving \eqref{eq:rec-ser-mod} by using a \texttt{for} loop.}
\end{listing}

Any function that can be defined by using iteration, can always be defined via
recursion and vice versa,
\cite{bohmReducingRecursionIteration1988,bohmReducingRecursionIteration1986}
see also
\cite{smolarskiMath60Notes2000,IterationVsRecursion2016}

there is, however, evidence to suggest that recursive functions are easier for people to understand \cite{benanderEmpiricalAnalysisDebugging2000} . Although independent research has shown that the specific language chosen can have a bigger effect on how well recursive as opposed to iterative code is understood \cite{sinhaCognitiveFitEmpirical1992}.

The relevant question is which method is often more appropriate, generally the process for
determining which is more appropriate is to the effect of:

\begin{enumerate}
\item Write the problem in a way that is easier to write or is more
appropriate for demonstration
\item If performance is a concern then consider restructuring in favour of iteration
\begin{itemize}
\item For interpreted languages such \textbf{\emph{R}} and \emph{Python}, loops are usually
faster, because of the overheads involved in creating functions
\cite{smolarskiMath60Notes2000} although there may be exceptions to this and
I'm not sure if this would be true for compiled languages such as \emph{Julia},
\emph{Java}, \textbf{\emph{C}} etc.
\end{itemize}
\end{enumerate}

\paragraph{Some Functions are more difficult to express with Recursion in}
\label{some-functions-are-more-difficult-to-express-with-recursion-in-python}
Attacking a problem recursively isn't always the best approach, consider the function \(g\left( k \right)\) from \eqref{eq:rec-ser}:


\begin{align}
    g\left( k \right) &=  \frac{\sqrt{2} }{2} \cdot   \frac{\sqrt{2+  \sqrt{3}}  }{3} \frac{\sqrt{2 +  \sqrt{3 +  \sqrt{4} } } }{4} \cdot  \ldots \frac{\sqrt{2 +  \sqrt{3 +  \ldots +  \sqrt{k} } } }{k} \nonumber \\
    &=  \prod^k_{i = 2} \left( \frac{f_i}{i}  \right) \quad : \quad f_{i} = \sqrt{i +  f_{i+1}} \nonumber
\end{align}

Observe that the difference between \eqref{eq:rec-ser} and \eqref{eq:rec-ser-mod} is
that the sequence essentially \emph{looks} forward, not back. To solve using a \texttt{for}
loop, this distinction is a non-concern because the list can be reversed using a built-in
such as \texttt{rev}, \texttt{reversed} or \texttt{reverse} in \emph{Python}, \textbf{\emph{R}} and \emph{Julia}
respectively, which means the same expression can be implemented.

To implement recursion however, the series needs to be restructured and this can become a little clumsy, see \eqref{eq:clumsy}:

\begin{align}
    g\left( k \right) &=  \prod^k_{i = 2} \left( \frac{f_i}{i}  \right) \quad : \quad f_{i} = \sqrt{\left( k- i \right)  +  f_{k - i - 1}} \label{eq:clumsy}
\end{align}

Now the function could be performed recursively in \emph{Python} in a similar
way as shown in listing \ref{rec-two}, but it's also significantly more confusing because the \(f\) function now has \(k\) as a parameter and this is only made significantly more complicated by the variable scope of functions across common languages used in Mathematics and Data science such as \texttt{bash}, \emph{Python}, \textbf{\emph{R}} and \emph{Julia} (see section \ref{variable-scope-nested}).


If however, the \texttt{for} loop approach was implemented, as shown in listing
\ref{iter-two}, the function would not significantly change, because the \texttt{reversed()} function can be
used to flip the list around.

What this demonstrates is that taking a different approach to simply describing
this function can lead to big differences in the complexity involved in solving
this problem.

\begin{listing}[htbp]
\begin{minted}[]{python}
from sympy import *
def h(k):
    if k > 2:
        return f(k, k) * f(k, k-1)
    else:
        return 1

def f(k, i):
    if k > i:
        return 1
    if i > 2:
        return sqrt((k-i) + f(k, k - i -1))
    else:
        return 1
\end{minted}
\caption{\label{rec-two}Using Recursion to Solve \eqref{eq:rec-ser}}
\end{listing}


\begin{listing}[htbp]
\begin{minted}[]{python}
from sympy import *
def h(k):
    k = k + 1 # OBOB
    l = [f(i) for i in range(1,k)]
    return prod(l)

def f(k):
    expr = 0
    for i in reversed(range(2, k+2)):
        expr = sqrt(i + expr, evaluate=False)
    return expr/(k+1)
\end{minted}
\caption{\label{iter-two}Using Iteration to Solve \eqref{eq:rec-ser}}
\end{listing}

\paragraph{Variable Scope of Nested Functions}
\label{variable-scope-nested}

\subsection{Fibonacci Sequence}
\label{sec:org45d637d}
The Fibonacci Sequence occurs in patterns observed in nature very frequently (see
\cite{shellyallenFibonacciNature,benedettapalazzoNumbersNatureFibonacci2016,MinarovaNikoletta2014TFSN,NatureGoldenRatio2018,robertlambHowAreFibonacci2008,ronknottFibonacciNumbersGolden2016})

This pops up all the time in natural sequences and fractals so we'll deal with
ways to solve it The \emph{Fibonacci Sequence} The \emph{Fibonacci Sequence} and the
\emph{Golden Ratio} both occur in patterns observed in nature and are fundamentally
related (see section \ref{fib-golden-ratio-proof}), in this section we lay out a
strategy to find an analytic solution to the \emph{Fibonacci Sequence} by relating it
to a continuous series and generalise this approach to any homogenous linear
recurrence relation.

The hope is that by identifying relationships between discrete and continuos systems insights can be drawn with regard to the occurrence of patterns related to the \emph{Fibonacci Sequence} and \emph{Golden Ratio} in nature.

\subsubsection{Computational Approach}
\label{define-the-fibonacci-numbers}
The \emph{Fibonacci} Numbers are given by:

\begin{align}
F_n = F_{n-1} + F_{n-2} \label{eq:fib-def}
\end{align}

This type of recursive relation can be expressed in \emph{Python} by using recursion,
as shown in listing \ref{fib-rec-0}, however using this function will reveal that it
is extraordinarily slow, as shown in listing \ref{time-slow}, this is because the
results of the function are not cached and every time the function is called
every value is recalculated\footnote{Dr. Hazrat mentions something similar in his book with respect to
\emph{Mathematica}\textsuperscript{\textregistered}
\cite[Ch. 13]{hazratMathematicaProblemCenteredApproach2015}}, meaning that the workload scales in
exponential as opposed to polynomial time.

The \texttt{functools} library for python includes the \texttt{@functools.lru\_cache} decorator
which will modify a defined function to cache results in memory
\cite{FunctoolsHigherorderFunctions}, this means that the recursive function will
only need to calculate each result once and it will hence scale in polynomial
time, this is implemented in listing \ref{fib-cache}.


\begin{listing}[htbp]
\begin{minted}[]{python}
  def rec_fib(k):
      if type(k) is not int:
          print("Error: Require integer values")
          return 0
      elif k == 0:
          return 0
      elif k <= 2:
          return 1
      return rec_fib(k-1) + rec_fib(k-2)
\end{minted}
\caption{\label{fib-rec-0}Defining the \emph{Fibonacci Sequence} \eqref{eq:fib-def} using Recursion}
\end{listing}

\begin{listing}[htbp]
\begin{minted}[]{python}
  start = time.time()
  rec_fib(35)
  print(str(round(time.time() - start, 3)) + "seconds")

## 2.245seconds
\end{minted}
\caption{\label{time-slow}Using the function from listing \ref{fib-rec-0} is quite slow.}
\end{listing}


\begin{listing}[htbp]
\begin{minted}[]{python}
  from functools import lru_cache

  @lru_cache(maxsize=9999)
  def rec_fib(k):
      if type(k) is not int:
          print("Error: Require Integer Values")
          return 0
      elif k == 0:
          return 0
      elif k <= 2:
          return 1
      return rec_fib(k-1) + rec_fib(k-2)


start = time.time()
rec_fib(35)
print(str(round(time.time() - start, 3)) + "seconds")
## 0.0seconds
\end{minted}
\caption{\label{fib-cache}Caching the results of the function previously defined \ref{time-slow}}
\end{listing}

\begin{minted}[]{python}
  start = time.time()
  rec_fib(6000)
  print(str(round(time.time() - start, 9)) + "seconds")

## 8.3923e-05seconds
\end{minted}

Restructuring the problem to use iteration will allow for even greater performance as demonstrated by finding \(F_{10^{6}}\) in listing \ref{fib-iter}. Using a compiled language such as \emph{Julia} however would be thousands of times faster still, as demonstrated in listing \ref{julia-fib}.



\begin{listing}[htbp]
\begin{minted}[]{python}
  def my_it_fib(k):
      if k == 0:
          return k
      elif type(k) is not int:
          print("ERROR: Integer Required")
          return 0
      # Hence k must be a positive integer

      i  = 1
      n1 = 1
      n2 = 1

      # if k <=2:
      #     return 1

      while i < k:
         no = n1
         n1 = n2
         n2 = no + n2
         i = i + 1
      return (n1)

  start = time.time()
  my_it_fib(10**6)
  print(str(round(time.time() - start, 9)) + "seconds")

 ## 6.975890398seconds
\end{minted}
\caption{\label{fib-iter}Using Iteration to Solve the Fibonacci Sequence}
\end{listing}

\begin{listing}[htbp]
\begin{minted}[]{julia}
function my_it_fib(k)
    if k == 0
        return k
    elseif typeof(k) != Int
        print("ERROR: Integer Required")
        return 0
    end
    # Hence k must be a positive integer

    i  = 1
    n1 = 1
    n2 = 1

    # if k <=2:
    #     return 1
    while i < k
       no = n1
       n1 = n2
       n2 = no + n2
       i = i + 1
    end
    return (n1)
end

@time my_it_fib(10^6)

##  my_it_fib (generic function with 1 method)
##    0.000450 seconds
\end{minted}
\caption{\label{julia-fib}Using Julia with an iterative approach to solve the 1 millionth fibonacci number}
\end{listing}

In this case however an analytic solution can be found by relating discrete
mathematical problems to continuous ones as discussed below at section .
\subsubsection{Exponential Generating Functions}
\label{exp-gen-func-fib-seq}
\paragraph{Motivation}
\label{motivation}
Consider the \emph{Fibonacci Sequence} from \eqref{eq:fib-def}:


\begin{align}
    a_{n}&= a_{n - 1} + a_{n - 2} \nonumber \\
\iff a_{n+  2} &= a_{n+  1} +  a_n \label{eq:fib-def-shift}
\end{align}


from observation, this appears similar in structure to the following \emph{ordinary
differential equation}, which would be fairly easy to deal with:


\begin{align*}
f''\left( x \right)- f'\left( x \right)- f\left( x \right)=  0
\end{align*}

By ODE Theory we have \(y \propto e^{m_{i}x}, \enspace i = 1, 2\):

\begin{align*}
f\left( x \right)= e^{mx} = \sum^{\infty}_{n= 0}   \left[ r^{m} \frac{x^n}{n!} \right]
\end{align*}

So using some sort of a transformation involving a power series may help to
relate the discrete problem back to a continuous one.

\paragraph{Example}
\label{solving-the-sequence}
Consider using the following generating function, (the derivative of the
generating function as in \eqref{eq:exp-gen-def-2} and \eqref{eq:exp-gen-def-3} is
provided in section \ref{Derivative-exp-gen-function})




\begin{align}
    f\left( x \right) &=  \sum^{\infty}_{n= 0}   \left[ a_{n} \cdot  \frac{x^n}{n!} \right]   \label{eq:exp-gen-def-1} \\
 \implies   f'\left( x \right) &=  \sum^{\infty}_{n= 0}   \left[ a_{n+1} \cdot  \frac{x^n}{n!} \right]   \label{eq:exp-gen-def-2} \\
\implies    f''\left( x \right) &=  \sum^{\infty}_{n= 0}   \left[ a_{n+2} \cdot  \frac{x^n}{n!} \right]   \label{eq:exp-gen-def-3}
\end{align}


So the recursive relation from \eqref{eq:fib-def-shift}  could be expressed :


\begin{align*}
a_{n+  2}    &= a_{n+  1} +  a_{n}\\
\frac{x^n}{n!}   a_{n+  2}    &= \frac{x^n}{n!}\left( a_{n+  1} +  a_{n}  \right)\\
\sum^{\infty}_{n= 0} \left[ \frac{x^n}{n!}   a_{n+  2} \right]        &= \sum^{\infty}_{n= 0}   \left[ \frac{x^n}{n!} a_{n+  1} \right]  + \sum^{\infty}_{n= 0}   \left[ \frac{x^n}{n!} a_{n}  \right]  \\
f''\left( x \right) &= f'\left( x \right)+  f\left( x \right)
\end{align*}

And hence by applying \eqref{eq:exp-gen-def-1}:

\begin{align}
f''\left( x \right) &= f'\left( x \right)+  f\left( x \right)
\end{align}


Using the theory of higher order linear differential equations with
constant coefficients it can be shown:


\begin{align*}
f\left( x \right)= c_1 \cdot  \mathrm{exp}\left[ \left( \frac{1- \sqrt{5} }{2} \right)x \right] +  c_2 \cdot  \mathrm{exp}\left[ \left( \frac{1 +  \sqrt{5} }{2} \right) \right]
\end{align*}


By equating this to the power series:


\begin{align*}
f\left( x \right)&= \sum^{\infty}_{n= 0}   \left[ \left( c_1\left( \frac{1- \sqrt{5} }{2} \right)^n +  c_2 \cdot  \left( \frac{1+ \sqrt{5} }{2} \right)^n \right) \cdot  \frac{x^n}{n} \right]
\end{align*}


Now given that:


\begin{align*}
f\left( x \right)= \sum^{\infty}_{n= 0}   \left[ a_n \frac{x^n}{n!} \right]
\end{align*}


We can conclude that:


\begin{align*}
a_n = c_1\cdot  \left( \frac{1- \sqrt{5} }{2} \right)^n +  c_2 \cdot  \left( \frac{1+  \sqrt{5} }{2} \right)
\end{align*}


By applying the initial conditions:


\begin{align*}
a_0= c_1 +  c_2  \implies  c_1= - c_2\\
a_1= c_1 \left( \frac{1+ \sqrt{5} }{2} \right) -  c_1 \frac{1-\sqrt{5} }{2}  \implies  c_1 = \frac{1}{\sqrt{5} }
\end{align*}


And so finally we have the solution to the \emph{Fibonacci Sequence} \ref{eq:fib-def-shift}:


\begin{align}
    a_n &= \frac{1}{\sqrt{5} } \left[ \left( \frac{1+  \sqrt{5} }{2}  \right)^n -  \left( \frac{1- \sqrt{5} }{2} \right)^n \right] \nonumber \\
&= \frac{\varphi^n - \psi^n}{\sqrt{5} } \nonumber\\
&=\frac{\varphi^n -  \psi^n}{\varphi - \psi} \label{eq:fib-sol}
\end{align}


where:

\begin{itemize}
\item \(\varphi = \frac{1+ \sqrt{5} }{2} \approx 1.61\ldots\)
\item \(\psi = 1-\varphi = \frac{1- \sqrt{5} }{2} \approx 0.61\ldots\)
\end{itemize}

\paragraph{Derivative of the Exponential Generating Function}
\label{Derivative-exp-gen-function}
Differentiating the exponential generating function has the effect of shifting the sequence to the backward: \cite{lehmanReadingsMathematicsComputer2010}

\begin{align}
    f\left( x \right) &= \sum^{\infty}_{n= 0}   \left[ a_n \frac{x^n}{n!} \right] \label{eq:exp-pow-series} \\
f'\left( x \right)) &= \frac{\mathrm{d} }{\mathrm{d} x}\left( \sum^{\infty}_{n= 0}   \left[ a_n \frac{x^n}{n!} \right]  \right) \nonumber \\
&= \frac{\mathrm{d}}{\mathrm{d} x} \left( a_0 \frac{x^0}{0!} +  a_1 \frac{x^1}{1!} +  a_2 \frac{x^2}{2!}+  a_3 \frac{x^3}{3! } +  \ldots \frac{x^k}{k!} \right) \nonumber \\
&= \sum^{\infty}_{n= 0}   \left[ \frac{\mathrm{d} }{\mathrm{d} x}\left( a_n \frac{x^n}{n!} \right) \right] \nonumber \\
&= \sum^{\infty}_{n= 0}   {\left[{ \frac{a_n}{{\left({ n- 1 }\right)!}} } x^{n- 1}  \right]} \nonumber \\
\implies f'(x) &= \sum^{\infty}_{n= 0}   {\left[{ \frac{x^n}{n!}a_{n+  1} }\right]} \label{eq:exp-pow-series-sol}
\end{align}

\subparagraph[Inductive Proof]{Inductive Proof\hfill{}\textsc{James}}
\label{sec:org9047f69}
This can be shown for all derivatives by way of induction, for

\begin{align}
f^{(k)}\left(x\right) = \sum_{n=0}^\infty\frac{a_{n+k}\cdot x^n}{n!} \quad \text{for}~k \ge 0
\end{align}

Assume that. \(f^{(k)}\left(x\right) = \sum_{n=0}^\infty\frac{a_{n+k}\cdot x^n}{n!}\)

Using this assumption, prove for the next element \$k+1\$\\

We need \(f^{(k+1)}(x) = \sum_{n=0}^\infty\frac{a_{n+k+1}\cdot x^n}{n!}\)

\begin{align*}
    \text{LHS} &= f^{(k+1)}(x)\\
    &= \frac{\mathrm{d}}{\mathrm{d}x}\left(f^{(k)}(x)\right)\\
    &= \frac{\mathrm{d}}{\mathrm{d}x}\left(\sum_{n=0}^\infty\frac{a_{n+k}\cdot x^n}{n!}\right)\quad \text{by assumption}\\
    &= \sum_{n=0}^\infty\frac{a_{n+k}\cdot n\cdot x^{n-1}}{n!}\\
    &= \sum_{n=1}^\infty\frac{a_{n+k}\cdot x^{n-1}}{(n-1)!}\\
    &= \sum_{n=0}^\infty\frac{a_{n+k+1}\cdot x^{n}}{n!}\\
    &= \text{RHS}
\end{align*}

Thus, if the derivative of the series shown in \eqref{eq:exp-gen-def-1} shifts the
sequence across, then every derivative thereafter does so as well, because the
first derivative has been shown to express this property
\eqref{eq:exp-pow-series-sol}, all derivates will.

\paragraph{Homogeneous Proof}
\label{sec:org624ab51}
An equation of the form:

\begin{align}
\sum^{n}_{i=0} \left[ c_{i} \cdot f^{(i)}(x) \right] = 0 \label{eq:hom-ode}
\end{align}

is said to be a homogenous linear ODE: \cite[Ch. 2]{zillDifferentialEquations2009a}

\begin{description}
\item[{Linear}] because the equation is linear with respect to \(f(x)\)
\item[{Ordinary}] because there are no partial derivatives (e.g. \(\frac{\partial }{\partial x}{\left({ f{\left({ x }\right)} }\right)}\)  )
\item[{Differential}] because the derivates of the function are concerned
\item[{Homogenous}] because the \textbf{\emph{RHS}} is 0
\begin{itemize}
\item A non-homogeous equation would have a non-zero RHS
\end{itemize}
\end{description}

There will be \(k\) solutions to a \(k^{\mathrm{th}}\) order linear ODE, each may be summed to produce a superposition which will also be a solution to the equation, \cite[Ch. 4]{zillDifferentialEquations2009a}  this will be considered as the desired complete solution (and this will be shown to be the only solution for the recurrence relation \eqref{eq:recurrence-relation-def}). These \(k\) solutions will be in one of two forms:

\begin{enumerate}
\item \(f(x)=c_{i} \cdot e^{m_{i}x}\)
\item \(f(x)=c_{i} \cdot x^{j}\cdot e^{m_{i}x}\)
\end{enumerate}

where:

\begin{itemize}
\item \(\sum^{k}_{i=0}\left[  c_{i}m^{k-i} \right] = 0\)
\begin{itemize}
\item This is referred to the characteristic equation of the recurrence relation or ODE \cite{levinSolvingRecurrenceRelations2018}
\end{itemize}
\item \(\exists i,j \in \mathbb{Z}^{+} \cap \left[0,k\right]\)
\begin{itemize}
\item These is often referred to as repeated roots \cite{levinSolvingRecurrenceRelations2018,zillMatrixExponential2009} with a multiplicity corresponding to the number of repetitions of that root \cite[\textsection 3.2]{nicodemiIntroductionAbstractAlgebra2007}
\end{itemize}
\end{itemize}

\subparagraph{Unique Roots of Characteristic Equation}
\label{uniq-roots-recurrence}
\begin{enumerate}
\item Example
\label{sec:org9dbe6e0}
An example of a recurrence relation with all unique roots is the fibonacci sequence, as described in section \ref{solving-the-sequence}.
\item Proof
\label{sec:org03e8a58}
Consider the linear recurrence relation \eqref{eq:recurrence-relation-def}:

\begin{align}
\sum^{n}_{i= 0}   \left[ c_i \cdot  a_i \right] = 0, \quad \exists c \in
\mathbb{R}, \enspace \forall i<k\in\mathbb{Z}^+ \nonumber \label{eq:recurrence-relation-def}
\end{align}
This implies:


\begin{align}
    \sum^{\infty}_{n= 0}   \left[ \sum^{k}_{i= 0}   \left[ \frac{x^n}{n!} c_i a_n \right]  \right]  &= 0 \\
    \sum^{\infty}_{n= 0}    \sum^{k}_{i= 0}    \frac{x^n}{n!} c_i a_n    &= 0 \\
        \sum^{k}_{i= 0} c_i \sum^{\infty}_{n= 0}    \frac{x^n}{n!}  a_n    &= 0
\end{align}

By implementing the exponential generating function as shown in
\eqref{eq:exp-gen-def-1}, this provides:

\begin{align}
   \sum^{k}_{i= 0}   \left[ c_i f^{\left( i \right)}\left( x \right) \right]
\end{align}


Now assume that the solution exists and all roots of the characteristic polynomial are unique (i.e. the solution is of the form \(f{\left({ x }\right)} \propto e^{m_i x}: \quad m_i \neq m_j \forall i\neq j\)), this implies that  \cite[Ch. 4]{zillDifferentialEquations2009a} :

\begin{align}
    f{\left({ x }\right)} = \sum^{k}_{i= 0}   {\left[{ k_i e^{m_i x} }\right]}, \quad \exists m,k \in \mathbb{C} \nonumber
\end{align}

This can be re-expressed in terms of the exponential power series, in order to relate the solution of the function \(f{\left({ x }\right)}\) back to a solution of the sequence \(a_n\), (see section for a derivation of the exponential power series):

\begin{align}
    \sum^{k}_{i= 0}   {\left[{ k_i e^{m_i x}  }\right]}  &= \sum^{k}_{i= 0}   {\left[{ k_i \sum^{\infty}_{n= 0}   \frac{{\left({ m_i x }\right)}^n}{n!}  }\right]}  \nonumber \\
							 &= \sum^{k}_{i= 0}  \sum^{\infty}_{n= 0}   k_i m_i^n \frac{x^n}{n!} \nonumber\\
							 &=    \sum^{\infty}_{n= 0} \sum^{k}_{i= 0}   k_i m_i^n \frac{x^n}{n!} \nonumber \\
							 &= \sum^{\infty}_{n= 0} {\left[{ \frac{x^n}{n!}  \sum^{k}_{i=0}   {\left[{ k_im^n_i }\right]}  }\right]}, \quad \exists k_i \in \mathbb{C}, \enspace \forall i \in \mathbb{Z}^+\cap {\left[{ 1, k }\right]}     \label{eq:unique-root-sol-power-series-form}
\end{align}

Recall the definition of the generating function from \ref{eq:exp-gen-def-proof}, by relating this to \eqref{eq:unique-root-sol-power-series-form}:

\begin{align}
    f{\left({ x }\right)} &= \sum^{\infty}_{n= 0}   {\left[{  \frac{x^n}{n!} a_n }\right]} \nonumber \\
&= \sum^{\infty}_{n= 0} {\left[{ \frac{x^n}{n!}  \sum^{k}_{i=0}   {\left[{ k_im^n_i }\right]}  }\right]}  \nonumber \\
      \implies  a_n &= \sum^{k}_{n= 0} {\left[{ k_im_i^n }\right]}     \nonumber \\ \nonumber
\square
\end{align}

This can be verified by the fibonacci sequence as shown in section \ref{solving-the-sequence}, the solution to the characteristic equation is \(m_1 = \varphi, m_2 = {\left({ 1-\varphi }\right)}\) and the corresponding solution to the linear ODE and recursive relation are:

\begin{alignat}{4}
    f{\left({ x }\right)} &= &c_1 e^{\varphi x} +  &c_2 e^{{\left({ 1-\varphi }\right)} x}, \quad &\exists c_1, c_2 \in \mathbb{R} \subset \mathbb{C} \nonumber \\
    \iff  a_n &= &k_1 n^{\varphi} +  &k_2 n^{1- \varphi}, &\exists k_1, k_2 \in \mathbb{R} \subset \mathbb{C} \nonumber
\end{alignat}
\end{enumerate}

\subparagraph{Repeated Roots of Characteristic Equation}
\label{rep-roots-recurrence}
\begin{enumerate}
\item Example
\label{sec:org8618087}
Consider the following recurrence relation:

\begin{align}
    a_n -  10a_{n+ 1} +  25a_{n+  2}&= 0 \label{eq:hom-repeated-roots-recurrence} \\
    \implies  \sum^{\infty}_{n= 0}   {\left[{ a_n \frac{x^n}{n!} }\right]} - 10 \sum^{\infty}_{n= 0}   {\left[{ \frac{x^n}{n!}+    }\right]} + 25 \sum^{\infty}_{n= 0 }   {\left[{  a_{n+  2 }\frac{x^n}{n!} }\right]}&= 0 \nonumber
\end{align}

By applying the definition of the exponential generating function at \eqref{eq:exp-gen-def-1} :

\begin{align}
    f''{\left({ x }\right)}- 10f'{\left({ x }\right)}+  25f{\left({ x }\right)}= 0 \nonumber \label{eq:rep-roots-func-ode}
\end{align}

By implementing the already well-established theory of linear ODE's, the characteristic equation for \eqref{eq:rep-roots-func-ode} can be expressed as:

\begin{align}
    m^2- 10m+  25 = 0 \nonumber \\
    {\left({ m- 5 }\right)}^2 = 0 \nonumber \\
    m= 5 \label{eq:rep-roots-recurrence-char-sol}
\end{align}

Herein lies a complexity, in order to solve this, the solution produced from \eqref{eq:rep-roots-recurrence-char-sol} can be used with the \emph{Reduction of Order} technique to produce a solution that will be of the form \cite[\textsection 4.3]{zillMatrixExponential2009}.

\begin{align}
    f{\left({ x }\right)}= c_1e^{5x} +  c_2 x e^{5x} \label{eq:rep-roots-ode-sol}
\end{align}

\eqref{eq:rep-roots-ode-sol} can be expressed in terms of the exponential power series in order to try and relate the solution for the function back to the generating function,
observe however the following power series identity (TODO Prove this in section ):

\begin{align}
    x^ke^x &= \sum^{\infty}_{n= 0}   {\left[{ \frac{x^n}{{\left({ n- k }\right)}!} }\right]}, \quad \exists k \in \mathbb{Z}^+ \label{eq:uniq-roots-pow-series-ident}
\end{align}

\textbf{Proof}
Consider the function \(f(x) = xe^x\). Using the taylor series formula we get the following:

\begin{align*}
    xe^x &= 0+\frac{1}{1!}x+\frac{2}{2!}x^2+\frac{3}{3!}x^3+\frac{4}{4!}x^4+\frac{5}{5!}x^5+\dots\\
    &= \sum_{n=0}^\infty \frac{nx^n}{n!}\\
    &= \sum_{n=1}^\infty \frac{x^n}{(n-1)!}
\end{align*}

Similarly, \(f(x) = x^2e^x\) will give:
\begin{align*}
    x^2e^x &= \frac{0}{0!} + \frac{0x}{1!} + \frac{2x^2}{2!} + \frac{6x^3}{3!} + \frac{12x^4}{4!} + \frac{20x^5}{5!} + \dots\\
    &= \frac{2\cdot 1x^2}{2!} + \frac{3\cdot 2 x^3}{3!} + \frac{4\cdot 3x^4}{4!} + \frac{5\cdot 4 x^5}{5!} + \dots\\
    &= \sum_{n=2}^\infty \frac{n(n-1)x^n}{n!}\\
    &= \sum_{n=2}^\infty \frac{x^n}{(n-2)!}
\end{align*}

If we continue this on, we get:

\begin{align*}
    x^ke^x = \sum_{n=k}^\infty \frac{x^n}{(n-k)!} \quad \text{for}~k \ge 0
\end{align*}

To verify, let's prove this by induction.
Prove \(f(x) = x^ke^x = \sum_{n=k}^\infty\frac{x^n}{(n-k)!}\) \text{for} \(k \ge 0\) \\

Test \(k=0\)
\begin{align*}
    LHS &= x^0e^x = e^x\\
    RHS &= \sum_{n=0}^\infty \frac{x^n}{n!} = e^x\\
\end{align*}
Therefore LHS = RHS, so \(k=0\) is true\\

Now assume true for all k, i.e. \$x\textsuperscript{k} e\textsuperscript{x} = \(\sum\)\textsubscript{n=k}\^{}\(\infty\)\frac{x^n}{(n-k)!}\$\\
Using this assumption, prove for the next element \$k+1\$\\
We need \$x\textsuperscript{k+1}e\textsuperscript{x} = \(\sum\)\textsubscript{n=k+1}\^{}\(\infty\)\frac{x^n}{(n-(k+1))!}\$\\
\begin{align*}
    \text{LHS} &= x^{k+1}e^x\\
    &= x\cdot x^{k}e^x\\
    &= x\cdot \sum_{n=k}^\infty\frac{x^n}{(n-k)!} \quad \text{(by assumption)}\\
    &= \sum_{n=k}^\infty\frac{x^{n+1}}{(n-k)!}\\
    &= \sum_{n=k+1}^\infty\frac{x^n}{(n-1-k)!} \quad \text{(re-indexing}~ n\text{)}\\
    &= \sum_{n=k+1}^\infty\frac{x^n}{(n-(k+1))!}\\
    &= RHS
\end{align*}
So by mathematical induction \(f(x) = x^ke^x = \sum_{n=k}^\infty\frac{x^n}{(n-k)!}\) \text{for} \(k \ge 0\)

Moving on, by applying identity \eqref{eq:uniq-roots-pow-series-ident} to equation \eqref{eq:rep-roots-ode-sol}

\begin{align}
    \implies  f{\left({ x }\right)} &= \sum^{\infty}_{n= 0}   {\left[{ c_1 \frac{{\left({ 5x }\right)}^n}{n!} }\right]}  +  \sum^{\infty}_{n= 0}   {\left[{ c_2 n \frac{{\left({ 5x^n }\right)}}{n{\left({ n-1 }\right)}!} }\right]} \nonumber \\
 &= \sum^{\infty}_{n= 0}   {\left[{ \frac{x^n}{n!} {\left({ c_{1}5^n +  c_2 n 5^n   }\right)} }\right]} \nonumber
\end{align}

Given the defenition of the exponential generating function from \eqref{eq:exp-gen-def-1}

\begin{align}
    f{\left({ x }\right)}&=     \sum^{\infty}_{n= 0}   {\left[{ a_n \frac{x^n}{n!} }\right]} \nonumber \\
    \iff a_n &= c_{15}^n +  c_2n_5^n \nonumber \\ \nonumber
    \ \nonumber \\
    \square \nonumber
\end{align}
\begin{enumerate}
\item Generalised Example
\label{sec:orgab372c4}

\item Proof
\label{sec:org2fcef27}
In order to prove the the solution for a \(k^{\mathrm{th}}\) order recurrence relation with \(k\) repeated


Consider a recurrence relation of the form:

\begin{align}
     \sum^{k}_{n= 0}   {\left[{ c_i a_n }\right]}  = 0 \nonumber \\
      \implies  \sum^{\infty}_{n= 0}   \sum^{k}_{i= 0}   c_i a_n \frac{x^n}{n!} = 0 \nonumber \\
      \sum^{k}_{i= 0}   \sum^{\infty}_{n= 0}   c_i a_n \frac{x^n}{n!} \nonumber
\end{align}

Using the value of the generating function \eqref{eq:exp-gen-def-1} and assuming that it corresponds to a charecteristic polynomial with only 1 root of multiplicity \(k\), the solution would hence be of the form:

\begin{align}
			 & \sum^{k}_{i= 0}   {\left[{ c_i m^i }\right]} = 0 \wedge m=B, \enspace  \exists! B \in \mathbb{C} \nonumber \\
 \implies      f{\left({ x }\right)}&= \sum^{k}_{i= 0}   {\left[{ x^i A_i e^{mx} }\right]}, \quad \exists A \in \mathbb{C}^+, \enspace \forall i \in {\left[{ 1,k }\right]} \cap \mathbb{N}  \label{eq:sol-rep-roots-ode} \\
\end{align}

Recall the following power series identity (proved in section xxx):

\begin{align}
x^k e^x = \sum^{\infty}_{n= 0} {\left[{ \frac{x^n}{{\left({ n- k }\right)}!} }\right]}     \nonumber
\end{align}

By applying this to \eqref{eq:sol-rep-roots-ode} :

\begin{align}
f{\left({ x }\right)}&=     \sum^{k}_{i= 0}   {\left[{ A_i \sum^{\infty}_{n= 0}   {\left[{ \frac{{\left({ x m }\right)}^n}{{\left({ n- i }\right)}!} }\right]}  }\right]} \nonumber \\
&=     \sum^{\infty}_{n= 0}   {\left[{ \sum^{k}_{i=0} {\left[{ \frac{x^n}{n!}  \frac{n!}{{\left({ n- i }\right)}} A_i m^n }\right]}       }\right]} # \\
&=     \sum^{\infty}_{n= 0} {\left[{ \frac{x^n}{n!}   \sum^{k}_{i=0} {\left[{  \frac{n!}{{\left({ n- i }\right)}} A_i m^n }\right]}       }\right]}
\end{align}

Recall the generating function that was used to get \ref{eq:gen-form-rep-roots-ode}:

\begin{align}
f{\left({ x }\right)}&= \sum^{\infty}_{n= 0}   {\left[{ a_n \frac{x^n}{n!} }\right]}      \nonumber \\
 \implies  a_n &= \sum^{k}_{i= 0}   {\left[{ A_i \frac{n!}{{\left({ n- i }\right)}!} m^n  }\right]} \nonumber \\
 &= \sum^{k}_{i= 0}   {\left[{ m^n A_i \prod_{0}^{k} {\left[{ n- {\left({ i- 1 }\right)} }\right]}   }\right]}
& \intertext{$\because \enspace i \leq k$} \notag \\
 &= \sum^{k}_{i= 0} {\left[{ A_i^* m^n n^i }\right]}, \quad \exists A_i \in \mathbb{C}, \enspace \forall i\leqk \in \mathbb{Z}^+ \nonumber \\
\ \nonumber \\
\square \nonumber
\end{align}
\end{enumerate}



\item General Proof
\label{sec:org3662177}
In sections \ref{uniq-roots-recurrence} and \ref{uniq-roots-recurrence} it was shown that a recurrence relation can be related to an ODE and then that solution can be transformed to provide a solution for the recurrence relation, when the charecteristic polynomial has either complex roots or 1 repeated root. Generally the solution to a linear ODE will be a superposition of solutions for each root, repeated or unique and so here it will be shown that these two can be combined and that the solution will still hold.

Consider a Recursive relation with constant coefficients:

$$
\sum^{\infty}_{n= 0}   \left[ c_i \cdot  a_n \right] = 0, \quad \exists c \in
\mathbb{R}, \enspace \forall i<k\in\mathbb{Z}^+
$$

This can be expressed in terms of the exponential generating function:

$$
\sum^{\infty}_{n= 0}   \left[ c_i \cdot  a_n \right] = 0\\
\implies \sum^{\infty}_{n= 0}   \left[\sum^{\infty}_{n= 0}   \left[ c_i \cdot
a_n  \right]   \right] = 0
$$

\begin{itemize}
\item Use the Generating function to get an ODE
\item The ODE will have a solution that is a combination of the above two forms
\item The solution will translate back to a combination of both above forms
\end{itemize}
\end{enumerate}

\paragraph{Fibonacci Sequence and the Golden Ratio}
\label{fib-golden-ratio-proof}
The \emph{Fibonacci Sequence} is actually very interesting, observe that the ratios of the terms converge to the \emph{Golden Ratio}:

\begin{align*}
    F_n &= \frac{\varphi^n-\psi^n}{\varphi-\psi} = \frac{\varphi^n-\psi^n}{\sqrt 5} \\
    \iff \frac{F_{n+1}}{F_n}	&= \frac{\varphi^{n+ 1} - \psi^{n+  1}}{\varphi^{n} - \psi^{n}} \\
    \iff \lim_{n \rightarrow \infty}\left[ \frac{F_{n+1}}{F_n} \right]	&= \lim_{n \rightarrow \infty}\left[ \frac{\varphi^{n+ 1} - \psi^{n+  1}}{\varphi^{n} - \psi^{n}} \right] \\
&= \frac{\varphi^{n+ 1} -\lim_{n \rightarrow \infty}\left[ \psi^{n +  1} \right] }{\varphi^{n} - \lim_{n \rightarrow \infty}\left[ \psi^n \right] } \\
\text{because $\mid \psi \mid < 0$ $n \rightarrow \infty \implies \psi^{n} \rightarrow 0$:} \\
&= \frac{\varphi^{n+  1} -  0}{\varphi^{n} -  0} \\
&= \varphi
\end{align*}

We'll come back to this later on when looking at spirals and fractals.

This can also be shown by using analysis, let \$L=\(\lim\)\textsubscript{n \(\rightarrow\) \(\infty\)} \left[ \frac\{F\textsubscript{n+1}\}\{F\textsubscript{n}\} \right], then:


\begin{align}
L\&= \frac\{F\textsubscript{n+ 1} \}\{f\textsubscript{n}\} \label{eq:fib-r-def} \\
\&= \frac\{F\textsubscript{n} +  F\textsubscript{n- 1} \}\{F\textsubscript{n}\} \\
\&= 1 +  \frac\{F\textsubscript{n - 1} \}\{F\textsubscript{n}\}  \\
\ldots
\text{by monotone convergence}
L\textsuperscript{2} - L - 1 = 0
\implies  L = \(\phi\)
\end{aligned}
Se  \href{https://mathcs.holycross.edu/\~groberts/Courses/MA242/HW/hw4-sols.pdf}{This Tutorial}

\subsubsection{Persian Recursion}
\label{sec:org9593c8d}
Although some recursive problems are a good fit for mathematical thinking such as the \emph{Fibonacci Sequence} discussed in section \ref{exp-gen-func-fib-seq} other problems
can be be easily interpreted computationally but they don't really carry over to any mathematical perspective, one good example of this is \emph{the persian recursion}, which is a simple procedure developed by Anne Burns in the 90s \cite{burnsPersianRecursion1997} that produces fantastic patterns upon feedback and iteration

The procedure begins with an empty or zero square matrix with sides \(2^{n}+1,
\enspace \exists n\in \mathbb{Z}^{+}\) and some value given to the edges:

\begin{enumerate}
\item Decide on some four variable function with a finite domain and range of size \(m\), for the example shown at listing \ref{persian-recursion-python} and in figure \ref{6-rug} the function \(f(w,x,y,z)=(w+x+y+z) \mod m\) was chosen.
\item Assign this value to the centre row and centre column of the matrix
\item Repeat this for each newly enclosed subsmatrix.
\end{enumerate}

This can be implemented computationally by defining a function that:

\begin{itemize}
\item takes the index of four corners enclosing a square sub-matrix of some matrix as input,
\item proceeds only if that square is some positive real value.
\item colours the centre column and row corresponding to a function of those four values
\item then calls itself on the corners of the four new sub-matrices enclosed by the
coloured row and column
\end{itemize}


\begin{figure}[htbp]
\centering
\includesvg[width=6cm]{persian}
\caption{\label{persian-recursion-diagram}Diagram of the Persian Recursion, implemented with \emph{Python} in listing \ref{persian-recursion-python}}
\end{figure}

This is demonstrated in listing \ref{persian-recursion-python} with python and produces the output shown in figures \ref{6-rug}, various interesting examples are provided in the appendix at section \ref{persian-recursion-examples}.

By mapping the values to colours, patterns emerge, this emergence of complex
patterns from simple rules is a well known and general phenomena that occurs in nature
\cite{EmergenceHowStupid2017,kivelsonDefiningEmergencePhysics2016}, as a matter of fact:

\begin{quote}
One of the suprising impacts of fractal geometry is that in the presence of
complex patterns there is a good chance that a very simple process is
responsible for it.
\end{quote}


Many patterns that occur in nature can be explained by relatively simple rules
that are exposed to feedback and iteration
\cite[p. 16]{peitgenChaosFractalsNew2004}, this is a centreal theme of Alan
Turing's \emph{The Chemical Basis For Morphogenesis}
\cite{turingChemicalBasisMorphogenesis1952} which we hope to look in the course of
this research.

\begin{listing}[htbp]
\begin{minted}[]{python}
%matplotlib inline
# m is colours
# n is number of folds
# Z is number for border
# cx is a function to transform the variables
def main(m, n, z, cx):
    import numpy as np
    import matplotlib.pyplot as plt

    # Make the Empty Matrix
    mat = np.empty([2**n+1, 2**n+1])
    main.mat = mat

    # Fill the Borders
    mat[:,0] = mat[:,-1] = mat[0,:] = mat[-1,:] = z

    # Colour the Grid
    colorgrid(0, mat.shape[0]-1, 0, mat.shape[0]-1, m)

    # Plot the Matrix
    plt.matshow(mat)

# Define Helper Functions
def colorgrid(l, r, t, b, m):
    # print(l, r, t, b)
    if (l < r -1):
        ## define the centre column and row
        mc = int((l+r)/2); mr = int((t+b)/2)

        ## Assign the colour
        main.mat[(t+1):b,mc] = cx(l, r, t, b, m)
        main.mat[mr,(l+1):r] = cx(l, r, t, b, m)

        ## Now Recall this function on the four new squares
                #l r   t   b
        colorgrid(l, mc, t, mr, m)    # NW
        colorgrid(mc, r, t, mr, m)    # NE
        colorgrid(l, mc, mr, b, m)    # SW
        colorgrid(mc, r, mr, b, m)    # SE

def cx(l, r, t, b, m):
    new_col = (main.mat[t,l] + main.mat[t,r] +  main.mat[b,l] + main.mat[b,r]) % m
    return new_col.astype(int)

main(5,6, 1, cx)
\end{minted}
\caption{\label{persian-recursion-python}Implementation of the persian recursion scheme in \emph{Python}}
\end{listing}



\begin{figure}[htbp]
\centering
\includesvg[width=6cm]{./persian-recursion-0}
\caption{\label{6-rug}Output produced by listing \ref{persian-recursion-python} with 6 folds}
\end{figure}

\subsection{Julia}
\label{sec:org987445d}
\subsubsection{Motivation}
\label{sec:org150d7b3}
Consider the iterative process \(x \rightarrow x^{2}, \enspace x \in \mathbb{R}\),
for values of \(x>1\) this process will diverge and for \(x<1\) it will converge.

Now Consider the iterative process \(z \rightarrow z^{2}, \enspace z \in \mathbb{C}\),
for values of \(\left\lvert z \right\rvert >1\) this process will diverge and for \(\left\lvert z \right\rvert <1\) it will converge.

Although this seems trivial this can be generalised.

Consider:

\begin{itemize}
\item The complex plane for \(\left\lvert z \right\rvert \leq 1\)
\item Some function \(f_{c}(z) = z^{2} + c, \quad c \leq 1 \in \mathbb{C}\) that can be used to iterate with
\end{itemize}

Every value on that plane will belong to one of the two following sets

\begin{itemize}
\item \(P_{c}\)
\begin{itemize}
\item The set of values on the plane that converge to zero (prisoners)
\item Define \(Q^{(k)}_{c}\) to be the the set of values confirmed as prisoners after \(k\) iterations of \(f_{c}\)
\begin{itemize}
\item this implies \(\lim_{k \rightarrow \infty} \left[ Q^{(k)}_{c}  \right] = P_{c}\)
\end{itemize}
\end{itemize}
\item \(E_{c}\)
\begin{itemize}
\item The set of values on the plane that tend to \(\infty\) (escapees)
\end{itemize}
\end{itemize}

In the case of \(f_{0}(z) = z^{2}\) all values \(\left\lvert z  \right \rvert \leq 1\) are bounded with \(\left\lvert z  \right \rvert = 1\) being an unstable stationary circle, but let's investigate what happens for different iterative functions like \(f_{1}(z) = z^{2} - 1\), despite how trivial this seems at first glance.

\subsubsection[Plotting the Sets]{Plotting the Sets\hfill{}\textsc{ATTACH}}
\label{sec:orgd34f354}
Although the convergence of values may appear simple at first, we'll implement a
strategy to plot the prisoner and escape sets on the complex plane.

Because this involves iteration and \emph{Python} is a little slow, We'll denote
complex values as a vector\footnote{See figure for the obligatory \emph{XKCD} Comic} and define the operations as described in
listing \ref{complex-vec}.\footnote{This technique was adapted from Chapter 7 of \emph{Math adventures with Python} \cite{farrellMathAdventuresPython2019}}

To implement this test we'll consider a function called \texttt{escape\_test} that applies an
iteration (in this case \(f_{0}: z \rightarrow z^{2}\)) until that value diverges or converges.

While iterating with \(f_{c}\) once \(\left\lvert z \right\rvert >
\mathrm{max}\left(\left\{c, 2\}\right)\), the value must diverge because
\(\left\lvert c \rvert\right \leq 1\), so rather than record whether or not the
value converges or diverges, the \texttt{escape\_test} can instead record the number of
iterations \((k)\) until the value has crossed that boundary and this will provide
a measurement of the rate of divergence.

Then the \texttt{escape\_test} function can be mapped over a matrix, where each element
of that matrix is in turn mapped to a point on the cartesian plane, the resulting matrix
can be visualised as an image \footnote{these cascading values are much like brightness in Astronomy}, this is implemented in listing
\ref{py-circle-code} and the corresponding output shown in .

with respect to listing \ref{py-circle-code}:

\begin{itemize}
\item Observe that the \texttt{magnitude} function wasn't used:
\begin{enumerate}
\item This is because a \texttt{sqrt} is a costly operation and comparing two squares saves an operation
\end{enumerate}
\end{itemize}



\begin{listing}[htbp]
\begin{minted}[]{python}
from math import sqrt
def magnitude(z):
    # return sqrt(z[0]**2 + z[1]**2)
    x = z[0]
    y = z[1]
    return sqrt(sum(map(lambda x: x**2, [x, y])))

def cAdd(a, b):
    x = a[0] + b[0]
    y = a[1] + b[1]
    return [x, y]


def cMult(u, v):
    x = u[0]*v[0]-u[1]*v[1]
    y = u[1]*v[0]+u[0]*v[1]
    return [x, y]
\end{minted}
\caption{\label{complex-vec}Defining Complex Operations with vectors}
\end{listing}

\begin{listing}[htbp]
\begin{minted}[]{python}
%matplotlib inline
%config InlineBackend.figure_format = 'svg'
import numpy as np
def escape_test(z, num):
    ''' runs the process num amount of times and returns the count of
    divergence'''
    c = [0, 0]
    count = 0
    z1 = z  #Remember the original value that we are working with
    # Iterate num times
    while count <= num:
        dist = sum([n**2 for n in z1])
        distc = sum([n**2 for n in c])
        # check for divergence
        if dist > max(2, distc):
            #return the step it diverged on
            return count
        #iterate z
        z1 = cAdd(cMult(z1, z1), c)
        count+=1
        #if z hasn't diverged by the end
    return num



p = 0.25 #horizontal, vertical, pinch (zoom)
res = 200
h = res/2
v = res/2

pic = np.zeros([res, res])
for i in range(pic.shape[0]):
    for j in range(pic.shape[1]):
        x = (j - h)/(p*res)
        y = (i-v)/(p*res)
        z = [x, y]
        col = escape_test(z, 100)
        pic[i, j] = col

import matplotlib.pyplot as plt

plt.axis('off')
plt.imshow(pic)
# plt.show()

\end{minted}
\caption{\label{py-circle-code}Circle of Convergence of \(z\) under recursion}
\end{listing}


This is precisely what we expected, but this is where things get interesting,
consider now the result if we apply this same procedure to \(f_{1}: z \rightarrow
z^{2} - 1\) or something arbitrary like \(f_{\frac{1}{4} + \frac{i}{2}}: z
\rightarrow z^{2} + (\frac{1}{4} + \frac{i}{2})\), the result is something
particularly unexpected, as shown in figures \ref{py-jl-1-plot} and \ref{py-jl-rab-plot}.


\begin{figure}[htbp]
\centering
\includesvg[width=9cm]{./julia-1}
\caption{\label{py-jl-1-plot}Circle of Convergence for \(f_{0}: z \rightarrow z^{2} - 1\)}
\end{figure}


\begin{figure}[htbp]
\centering
\includesvg[width=9cm]{./julia-rab}
\caption{\label{py-jl-rab-plot}Circle of Convergence for \(f_{\frac{1}{4} + \frac{i}{2}}: z \rightarrow z^{2} + \frac{1}{4} + \frac{i}{2}\)}
\end{figure}

Now this is particularly interesting, to investigate this further consider the
more general function \(f_{0.8 e^{\pi i \tau}}: z \rightarrow z^{2} + 0.8 e^{\pi
i \tau}, \enspace \tau \in \mathbb{R}\), many fractals can be generated using
this set by varying the value of \(\tau\)\footnote{This approach was inspired by an animation on the \emph{Julia Set} Wikipedia article \cite{JuliaSet2020}}.

\emph{Python} is too slow for this, but the \emph{Julia} programming language, as a
compiled language, is significantly faster and has the benefit of treating
complex numbers as first class citizens, these images can be generated in
\emph{Julia} in a similar fashion as before, with the specifics shown in listing
\ref{julia-gen-fracs}. The \texttt{GR} package appears to be the best plotting library
performance wise and so was used to save corresponding images to disc, this is
demonstrated in listing \ref{GR-save} where 1200 pictures at a 2.25 MP resolution were produced. \footnote{On my system this took about 30 minutes.}

A subset of these images can be combined using \emph{ImageMagick} and \texttt{bash} to
create a collage, \emph{ImageMagick} can also be used to produce a \texttt{gif} but it often
fails and a superior approach is to use \texttt{ffmpeg}, this is demonstrated in
listing \ref{bash-frac-join}, the collage is shown in figure \ref{montage-frac} and a corresponding
animation is \href{https://dl.dropboxusercontent.com/s/rbu25urfg8sbwfu/out.gif?dl=0}{available online}\footnote{\href{https://dl.dropboxusercontent.com/s/rbu25urfg8sbwfu/out.gif?dl=0}{https://dl.dropboxusercontent.com/s/rbu25urfg8sbwfu/out.gif?dl=0}}].

\begin{listing}[htbp]
\begin{minted}[]{julia}
# * Define the Julia Set
"""
Determine whether or not a value will converge under iteration
"""
function juliaSet(z, num, my_func)
    count = 1
    # Remember the value of z
    z1 = z
    # Iterate num times
    while count ≤ num
        # check for divergence
        if abs(z1)>2
            return Int(count)
        end
        #iterate z
        z1 = my_func(z1) # + z
        count=count+1
    end
        #if z hasn't diverged by the end
    return Int(num)
end

# * Make a Picture
"""
Loop over a matrix and apply apply the julia-set function to
the corresponding complex value
"""
function make_picture(width, height, my_func)
    pic_mat = zeros(width, height)
    zoom = 0.3
    for i in 1:size(pic_mat)[1]
        for j in 1:size(pic_mat)[2]
            x = (j-width/2)/(width*zoom)
            y = (i-height/2)/(height*zoom)
            pic_mat[i,j] = juliaSet(x+y*im, 256, my_func)
        end
    end
    return pic_mat
end

\end{minted}
\caption{\label{julia-gen-fracs}Produce a series of fractals using julia}
\end{listing}

\begin{listing}[htbp]
\begin{minted}[]{julia}
# * Use GR to Save a Bunch of Images
  ## GR is faster than PyPlot
using GR
function save_images(count, res)
    try
        mkdir("/tmp/gifs")
    catch
    end
    j = 1
    for i in (1:count)/(40*2*π)
        j = j + 1
        GR.imshow(make_picture(res, res, z -> z^2 + 0.8*exp(i*im*9/2))) # PyPlot uses interpolation = "None"
        name = string("/tmp/gifs/j", lpad(j, 5, "0"), ".png")
        GR.savefig(name)
    end
end

save_images(1200, 1500) # Number  and Res
\end{minted}
\caption{\label{GR-save}Generate and save the images with GR}
\end{listing}

\begin{listing}[htbp]
\begin{minted}[]{bash}
# Use montage multiple times to get recursion for fun
montage (ls *png | sed -n '1p;0~600p') 0a.png
montage (ls *png | sed -n '1p;0~100p') a.png
montage (ls *png | sed -n '1p;0~50p') -geometry 1000x1000  a.png

# Use ImageMagick to Produce a gif (unreliable)
convert -delay 10 *.png 0.gif

# Use FFMpeg to produce a Gif instead
ffmpeg                    \
    -framerate 60         \
    -pattern_type glob    \
    -i '*.png'            \
    -r 15                 \
    out.mov


\end{minted}
\caption{\label{bash-frac-join}Using \texttt{bash}, \texttt{ffmpeg} and \emph{ImageMagick} to combine the images and produce an animation.}
\end{listing}

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{/home/ryan/Dropbox/Studies/2020Spring/QuantProject/Current/Python-Quant/Outline/_20200826_005334a.png}
\caption{\label{montage-frac}Various fracals corresponding to \(f_{0.8 e^{\pi i \tau}}\)}
\end{figure}

\subsection{MandelBrot}
\label{sec:org2418b02}
Investigating these fractals, a natural question might be whether or not any
given \(c\) value will produce a fractal that is an open disc or a closed disc.

So pick a value \(\left\lvert \gamma \right \rvert < 1\) in the complex plane and
use it to produce the julia set \(f_{\gamma}\), if the corresponding prisoner set
\(P\) is closed we this value is defined as belonging to the \emph{Mandelbrot} set.

It can be shown (and I intend to show it generally), that this set is equivalent to re-implementing the previous strategy such that \(z \rightarrow z^{2} + z_{0}\) where \(z_{0}\) is unchanging or more clearly as a seqeuence:

\begin{align}
z_{n+1} &= z^{2}_n + c \label{eq:mb-sequence}
z_{0}   &= c
\end{align}

This strategy is implemented in listing 

\begin{listing}[htbp]
\begin{minted}[]{python}
%matplotlib inline
%config InlineBackend.figure_format = 'svg'
def mandelbrot(z, num):
    ''' runs the process num amount of times and returns the count of
    divergence'''
    count = 0
    # Define z1 as z
    z1 = z
    # Iterate num times
    while count <= num:
        # check for divergence
        if magnitude(z1) > 2.0:
            #return the step it diverged on
            return count
        #iterate z
        z1 = cAdd(cMult(z1, z1),z)
        count+=1
        #if z hasn't diverged by the end
    return num

import numpy as np


p = 0.25 # horizontal, vertical, pinch (zoom)
res = 200
h = res/2
v = res/2

pic = np.zeros([res, res])
for i in range(pic.shape[0]):
    for j in range(pic.shape[1]):
        x = (j - h)/(p*res)
        y = (i-v)/(p*res)
        z = [x, y]
        col = mandelbrot(z, 100)
        pic[i, j] = col

import matplotlib.pyplot as plt
plt.imshow(pic)
# plt.show()
\end{minted}
\caption{\label{py-mandelbrot-code}All values of \(c\) that lead to a closed \emph{Julia-set}}
\end{listing}

\begin{center}
\includesvg[width=.9\linewidth]{./mandelbrot-py}
\end{center}

This is however fairly underwhelming, by using a more powerful language a much
larger image can be produced, in \emph{Julia} producing a 4 GB, 400 MP image will
take about 10 minutes, this is demonstrated in listing 
and the corresponding FITS image is \href{https://www.dropbox.com/s/jd5qf1pi2h68f2c/mandelbrot-400mpx.fits?dl=0}{available-online.}\footnote{\href{https://www.dropbox.com/s/jd5qf1pi2h68f2c/mandelbrot-400mpx.fits?dl=0}{https://www.dropbox.com/s/jd5qf1pi2h68f2c/mandelbrot-400mpx.fits?dl=0}}

\begin{minted}[]{julia}
function mandelbrot(z, num, my_func)
    count = 1
    # Define z1 as z
    z1 = z
    # Iterate num times
    while count ≤ num
        # check for divergence
        if abs(z1)>2
            return Int(count)
        end
        #iterate z
        z1 = my_func(z1) + z
        count=count+1
    end
        #if z hasn't diverged by the end
    return Int(num)
end

function make_picture(width, height, my_func)
    pic_mat = zeros(width, height)
    for i in 1:size(pic_mat)[1]
        for j in 1:size(pic_mat)[2]
            x = j/width
            y = i/height
            pic_mat[i,j] = mandelbrot(x+y*im, 99, my_func)
        end
    end
    return pic_mat
end


using FITSIO
function save_picture(filename, matrix)
    f = FITS(filename, "w");
    # data = reshape(1:100, 5, 20)
    # data = pic_mat
    write(f, matrix)  # Write a new image extension with the data

    data = Dict("col1"=>[1., 2., 3.], "col2"=>[1, 2, 3]);
    write(f, data)  # write a new binary table to a new extension

    close(f)
end

# * Save Picture
#------------------------------------------------------------
my_pic = make_picture(20000, 20000, z -> z^2) 2000^2 is 4 GB
save_picture("/tmp/a.fits", my_pic)

\end{minted}

\subsubsection{GNU Plot}
\label{sec:org5810816}
Another approach to visualise this set is by creating a 3d surface plot where
the z-axis is mapped to the time taken until divergence, this can be acheived by
using gnuplot as demonstrated in listing \ref{gnuplot-mandelbrot-initial}.\footnote{See \cite{GnuplotFractalMandelbrot} for an excellent, albeit quite old, resource on GNUPlot.}

All the following code was adapted from online sources, they however correspond to an older release
and newer versions of GNUPlot:

\begin{itemize}
\item have a recursion limit
\item methods to loop functions
\end{itemize}

So one of our desires in this project is to visualise a much more detailed 3d
model in GNUPlot by modifying the code to use iteration as opposed to recursion. Generally I would like to write a


I'd also like to implement some process to generate a golden spiral as shown in figure \ref{golden-spiral}.


\begin{figure}[htbp]
\centering
\includesvg[width=9cm]{golden-spiral}
\caption{\label{golden-spiral}Circle of Convergence for \(f_{0}: z \rightarrow z^{2} - 1\)}
\end{figure}

\begin{listing}[htbp]
\begin{minted}[]{gnuplot}
complex(x,y) = x*{1,0}+y*{0,1}
julia(x,y,z,n) = (abs(z)>2.0 || n>=200) ? \
                  n : julia(x,y,z*z+complex(x,y),n+1)

mandelbrot(x,y,z,n) = (abs(z)>2.0 || n>=200) ? \
                  n : mandelbrot(x,y,z*z+complex(x,y),n+1)

set xrange [-1.5:1.5]
set yrange [-1.5:1.5]
set logscale z
set isosample 150
set hidden3d
set contour
a= 0.36
b= 0.1
# Julia Set
splot julia(a,b,complex(x,y),0)  notitle

# MandelBrot Set
# splot mandelbrot(x,y,complex(x,y),0) notitle
\end{minted}
\caption{\label{gnuplot-mandelbrot-initial}Visualising the Mandelbrot set as a 3D surface Plot}
\end{listing}

\begin{center}
\includesvg[width=.9\linewidth]{one}
\end{center}



\href{http://folk.uio.no/inf3330/scripting/doc/gnuplot/Kawano/fractal/mandelbrot-e.html}{reference for image}

\begin{listing}[htbp]
\begin{minted}[]{gnuplot}

complex(x,y) = x*{1,0}+y*{0,1}
julia(x,y,z,n) = (abs(z)>2.0 || k>=200) ? \
                  k : julia(x,y,z*z+complex(x,y),n+1)

set xrange [-1.5:1.5]
set yrange [-1.5:1.5]
set logscale z
set isosample 150
set hidden3d
set contour
a= 0.25
b= 0.75
splot julia(a,b,complex(x,y),0) notitle
\end{minted}
\caption{\label{gnuplot-julia}Use GNUPlot to produce plot of  julia set}
\end{listing}

\begin{center}
\includesvg[width=.9\linewidth]{two}
\end{center}






GNU Plot can also make excellent 2d renditions of fractals, an example of how to
perform this can be found on \emph{Rosetta Code} \cite{MandelbrotSetRosetta} and is demonstrated in listing \ref{flat-gnuplot}.


\begin{listing}[htbp]
\begin{minted}[]{gnuplot}
R = 2
k = 100
complex (x, y) = x * {1, 0} + y * {0, 1}
mandelbrot (z, z0, n) = n == k || abs (z) > R ? n : mandelbrot (z ** 2 + z0, z0, n + 1)
set samples 200
set isosamples 200
set pm3d map
set size square
splot [-2 : 2] [-2 : 2] mandelbrot (complex (0, 0), complex (x, y), 0) notitle
\end{minted}
\caption{\label{flat-gnuplot}Flat Mandelbrot set built using rosetta code.}
\end{listing}
\subsection{Relevant Sources}
\label{sec:orgbd69560}
To guide research in this area the following books were going to act as guides, in particular \emph{Chaos and Fractals} by Otto is a primary resource:


List the books from Dropbox here.

Also Ron Knotts website looks very helpful \cite{ronknottFibonacciNumbersGolden2016}

\section{Outline}
\label{sec:org59bafa8}
\begin{enumerate}
\item Intro Prob
\item Variable Scope
\item Problem Showing Recursion
\begin{itemize}
\item All Different Methods
\begin{itemize}
\item Discuss all Different Methods
\item Discuss Vectorisation
\item Is this needed in Julia
\item Comment on Faster to go column Wise
\end{itemize}
\end{itemize}
\item Discuss Loops
\item Show Rug
\item Fibonacci
\begin{itemize}
\item The ratio of fibonacci converges to \(\phi\)
\item Golden Ratio
\begin{itemize}
\item If you make a rectangle with the golden ratio you can cut it up under
recursion to get another one, keep doing this and eventually a logarithmic
spiral pops out, also the areas follow a fibonacci sequence.
\item Look at the spiral of nautilus shells
\end{itemize}
\end{itemize}
\item Discuss isomorphisms for recursive Relations
\item Jump to Lorenz Attractor
\item Now Talk about Morphogenesis
\item Fractals
\begin{itemize}
\item Many Occur in Nature
\begin{itemize}
\item Mountain Ranges, compare to MandelBrot
\item Sun Flowers
\item Show the golden Ratio
\end{itemize}
\item Fractals are all about recursion and iteration, so this gives me an excuse to look at them
\begin{itemize}
\item Show MandelBrot
\begin{itemize}
\item Python
\begin{itemize}
\item Sympy Slow
\item Numpy Fast
\end{itemize}
\item Julia brings Both Benefits
\begin{itemize}
\item Show Large MandelBrot
\end{itemize}
\item Show Julia Set
\begin{itemize}
\item Show Julia Set Gif
\end{itemize}
\end{itemize}
\end{itemize}
\end{itemize}
\item Things I'd like to show
\begin{itemize}
\item Simulate stripes and animal patterns
\item Show some math behind spirals in Nautilus Shells
\item Golden Rectangle
\begin{itemize}
\item Throw in some recursion
\item Watch the spiral come out
\item Record the areas and show that they are Fibonacci
\end{itemize}
\item That the ratio of Fibonacci Converges to Phi
\item Any Connection to the Reimann Sphere
\item Lorrenz Attractor
\begin{itemize}
\item How is this connected to the lorrenz attractor
\end{itemize}
\item What are the connections between discrete iteration and continuous systems such as the julia set and the lorrenz attractor
\end{itemize}
\item Things I'd like to Try (in order to see different ways to approach Problems)
\begin{itemize}
\item Programming Languages and CAS
\begin{itemize}
\item Julia
\begin{itemize}
\item SymEngine
\end{itemize}
\item Maxima
\item Julia
\end{itemize}
\item Visualisation
\begin{itemize}
\item Makie
\item Plotly
\item GNUPlot
\end{itemize}
\end{itemize}
\item Open Questions:
\begin{itemize}
\item can we simulate animal patterns
\item can we simulate leaves
\item can we show that the gen func deriv \ref{Derivative-exp-gen-function}
\item can we prove homogenous recursive relation
\item I want to look at the lorrenz attractor
\item when partiles are created by the the LHC, do they follow a fractal like pattern?
\item Create a Fractal Landscape, does this resemble things seen in nautre? \cite[p. 464]{peitgenChaosFractalsNew2004}
\item Can I write an algorighm to build a tree in the winter?
\item Can I develop my own type of persian recursion?
\item Show the relationship between the golden ratio and the logarithmic spiral.
\begin{itemize}
\item and show that the fibonacci numbers pop out as area
\begin{itemize}
\item Prove this
\end{itemize}
\end{itemize}
\item Is there any relationship between the Cantor Prisoner set and the Julia Sets?
\item Work with Matt to investigate Julia Sets for Quaternion \cite[\textsection 13.9]{peitgenChaosFractalsNew2004}
\item I'd like to write a program to solve sudoku problems as well
\end{itemize}
\end{enumerate}

\section{Download RevealJS}
\label{sec:org8141e03}
So first do \texttt{M-x package-install ox-reveal} then do \texttt{M-x load-library} and then look for \texttt{ox-reveal}

\begin{minted}[]{elisp}
(load "/home/ryan/.emacs.d/.local/straight/build/ox-reveal/ox-reveal.el")
\end{minted}

Download Reveal.js and put it in the directory as \texttt{./reveal.js}, you can do that with something like this:

\begin{minted}[]{bash}
# cd /home/ryan/Dropbox/Studies/2020Spring/QuantProject/Current/Python-Quant/Outline/
wget https://github.com/hakimel/reveal.js/archive/master.tar.gz
tar -xzvf master.tar.gz && rm master.tar.gz
mv reveal.js-master reveal.js
\end{minted}

Then just do \texttt{C-c e e R R} to export with RevealJS as opposed to PHP you won't need a fancy server, just open it in the browser.

\section{Heres a Gif}
\label{sec:orgcc7e77d}
So this is a very big Gif that I'm using:

How did I make the Gif??

\url{https://dl.dropboxusercontent.com/s/rbu25urfg8sbwfu/out.gif?dl=0}

\section{Give a brief Sketch of the project}
\label{sec:org1a81ba9}

Of particular interest are the:
\begin{itemize}
\item gik
\item fits image
\end{itemize}

\begin{minted}[]{bash}
code /home/ryan/Dropbox/Studies/QuantProject/Current/Python-Quant/ & disown
xdg-open /home/ryan/Dropbox/Studies/2020Spring/QuantProject/Current/Python-Quant/Problems/Chaos/mandelbrot-400mpx.fits
\end{minted}

Here's what I gatthered from the week 3 slides

\subsection{Topic / Context}
\label{sec:org93c0103}
We are interested in the theory of problem solving, but in particular the
different approaches that can be taken to attacking a problem.

Essentially this boils down to looking at how a computer scientist and
mathematician attack a problem, although originally I thought there was no
difference, after seeing the odd way Roozbeh attacks problems I see there is a big difference.
\subsection{Motivation}
\label{sec:org0403ad0}

\subsection{Basic Ideas}
\label{sec:orgb1795ae}
\begin{itemize}
\item Look at FOSS CAS Systems
\begin{itemize}
\item Python (Sympy)
\item Julia
\begin{itemize}
\item Sympy integration
\item symEngine
\item Reduce.jl
\item Symata.jl
\end{itemize}
\end{itemize}

\item Maybe look at interactive sessions:
\begin{itemize}
\item Like Jupyter
\item Hydrogen
\item TeXmacs
\item org-mode?
\end{itemize}
\end{itemize}

After getting an overview of SymPy let's look at problems that are interesting (chaos, morphogenesis and order from disarray etc.)

\subsection{Where are the Mathematics}
\label{sec:org61d92c9}

\begin{itemize}
\item Trying to look at the algorithms underlying functions in Python/Sympy and other Computer algebra tools such as Maxima, Maple, Mathematica, Sage, GAP and Xcas/Giac, Yacas, Symata.jl, Reduce.jl, SymEngine.jl
\begin{itemize}
\item For Example Recursive Relations
\end{itemize}
\item Look at solving some problems related to chaos theory maybe
\begin{itemize}
\item Mandelbrot and Julia Sets
\end{itemize}
\item Look at solving some problems related to Fourier Transforms maybe
\end{itemize}


AVOID DETAILS, JUST SKETCH THE PROJECT OUT.

\subsection{Don't Forget we need a talk}
\label{sec:org23bdeaf}
\subsubsection{Slides In Org Mode}
\label{sec:org6ecb860}
\begin{itemize}
\item \href{https://orgmode.org/worg/org-tutorials/non-beamer-presentations.html}{Without Beamer}
\item \href{https://orgmode.org/worg/exporters/beamer/tutorial.html}{With Beamer}
\end{itemize}
\section{Undecided}
\label{sec:orge80e58c}
\subsubsection{Determinant}
\label{sec:org433f973}
Computational thinking can be useful in problems related to modelling, consider
for example some matrix \(n\times n\) matrix \(B_n\) described by \eqref{eq:bn-matrix} :

\begin{align}
b_{ij} = \begin{cases}
\frac{1}{2j- i^2}, &\text{ if } i > j \\
\frac{i}{i- j}+  \frac{1}{n^2- j - i}, &\text{ if } j>i \\
0 &\text{ if } i = j
\end{cases} \label{eq:bn-matrix}
\end{align}

Is there a way to predict the determinant of such a matrix for large values?

From the perspective of linear algebra this is an immensely difficult problem
and there isn't really a clear place to start.

From a numerical modelling perspective however, as will be shown, this a fairly trivial problem.

\paragraph{Create the Matrix}
\label{create-the-matrix}
Using \emph{Python} and \texttt{numpy}, a matrix can be generated as an \texttt{array} and by
iterating through each element of the matrix values can be attributed like so:

\begin{minted}[]{python}
import numpy as np
n = 2
mymat = np.empty([n, n])
for i in range(mymat.shape[0]):
    for j in range(mymat.shape[1]):
        print("(" + str(i) + "," + str(j) + ")")
\end{minted}

\begin{verbatim}
  (0,0)
  (0,1)
  (1,0)
  (1,1)
\end{verbatim}

and so to assign the values based on the condition in \eqref{eq:bn-matrix}, an
\texttt{if} test can be used:

\begin{minted}[]{python}
  def BuildMat(n):
      mymat = np.empty([n, n])
      for i in range(n):
          for j in range(n):
              # Increment i and j by one because they count from zero
              i += 1; j += 1
              if (i > j):
                  v = 1/(2*j - i**2)
              elif (j > i):
                  v = 1/(i-j) + 1/(n**2 - j - i)
              else:
                  v = 0
              # Decrement i and j so the index lines up
              i -= 1; j -= 1
              mymat[j, i] = v
      return mymat

  BuildMat(3)
\end{minted}

\begin{verbatim}
  array([[ 0.        , -0.5       , -0.14285714],
         [-0.83333333,  0.        , -0.2       ],
         [-0.3       , -0.75      ,  0.        ]])
\end{verbatim}

\paragraph{Find the Determinant}
\label{find-the-determinant}
\emph{Python}, being an object orientated language has methods belonging to objects of different types, in this case the \texttt{linalg} method has a \texttt{det} function that can be used to return the determinant of any given matrix like so:

\begin{listing}[htbp]
\begin{minted}[]{python}
  def detMat(n):
      ## Sympy
      # return Determinant(BuildMat(n)).doit()
      ## Numpy
      return np.linalg.det(BuildMat(n))
  detMat(3)
\end{minted}
\caption{\label{make-det}Building a Function to return the determinant of the matrix described in \eqref{eq:bn-matrix}}
\end{listing}

\begin{verbatim}
  -0.11928571428571424
\end{verbatim}

\paragraph{Find the Determinant of Various Values}
\label{find-the-determinant-of-various-values}
To solve this problem, all that needs to be considered is the size of the \(n\) and the corresponding determinant, this could be expressed as a set as shown in \eqref{eq:set-determ}:

\begin{align}
\left\{ \mathrm{det}\left( M(n) \right) \mid M \in \mathbb{Z}^{+} \leq 30  \right\} \label{eqref:eq:set-determ}
\end{align}
where:
\begin{itemize}
\item \(M\) is a function that transforms an integer to a matrix as per \eqref{eq:bn-matrix}
\end{itemize}

Although describing the results as a set \eqref{eqref:eq:set-determ} is a little odd, it is consistent with the idea of list and set comprehension in \emph{Python} \cite{DataStructuresPython} and \emph{Julia} \cite{MultidimensionalArraysJulia} as shown in listing \ref{list-comp}

\subparagraph{Generate a list of values}
\label{instead-use-absolute-value}
Using the function created in listing \ref{make-det}, a corresponding list of values can be generated:

\begin{listing}[htbp]
\begin{minted}[]{python}
  def detMat(n):
      return abs(np.linalg.det(BuildMat(n)))

  # We double all numbers using map()
  result = map(detMat, range(30))

  # print(list(result))
  [round(num, 3) for num in list(result)]
\end{minted}
\caption{\label{list-comp}Generate a list using list-comprehension}
\end{listing}

\begin{verbatim}
  [1.0,
   0.0,
   0.0,
   0.119,
   0.035,
   0.018,
   0.013,
   0.01,
   0.008,
   0.006,
   0.005,
   0.004,
   0.004,
   0.003,
   0.003,
   0.002,
   0.002,
   0.002,
   0.002,
   0.001,
   0.001,
   0.001,
   0.001,
   0.001,
   0.001,
   0.001,
   0.001,
   0.001,
   0.001,
   0.001]
\end{verbatim}

\subparagraph{Create a Data Frame}
\label{create-a-data-frame}
\begin{minted}[]{python}
  import pandas as pd

  data = {'Matrix.Size': range(30),
          'Determinant.Value': list(map(detMat, range(30)))
  }



  df = pd.DataFrame(data, columns = ['Matrix.Size', 'Determinant.Value'])

  print(df)
\end{minted}

\begin{verbatim}
  Matrix.Size  Determinant.Value
  0             0           1.000000
  1             1           0.000000
  2             2           0.000000
  3             3           0.119286
  4             4           0.035258
  5             5           0.018062
  6             6           0.013023
  7             7           0.009959
  8             8           0.007822
  9             9           0.006288
  10           10           0.005158
  11           11           0.004304
  12           12           0.003645
  13           13           0.003125
  14           14           0.002708
  15           15           0.002369
  16           16           0.002090
  17           17           0.001857
  18           18           0.001661
  19           19           0.001494
  20           20           0.001351
  21           21           0.001228
  22           22           0.001121
  23           23           0.001027
  24           24           0.000945
  25           25           0.000872
  26           26           0.000807
  27           27           0.000749
  28           28           0.000697
  29           29           0.000650
\end{verbatim}

\subparagraph{Plot the Data frame}
\label{plot-the-data-frame}
Observe that it is necessary to use \texttt{copy}, \emph{Julia} and \emph{Python}
\textbf{unlike} \emph{Mathematica} and \textbf{\emph{R}} only create links between data, they do
not create new objects, this can cause headaches when rounding data.

\begin{minted}[]{python}
  from plotnine import *
  import copy

  df_plot = copy.copy(df[3:])
  df_plot['Determinant.Value'] = df_plot['Determinant.Value'].astype(float).round(3)
  df_plot

  (
      ggplot(df_plot, aes(x = 'Matrix.Size', y = 'Determinant.Value')) +
          geom_point() +
          theme_bw() +
          labs(x = "Matrix Size", y = "|Determinant Value|") +
          ggtitle('Magnitude of Determinant Given Matrix Size')

  )




\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{e3d03c21dd72428e88b7fc2c722737046510dbb2.png}
\end{center}

\begin{verbatim}
  <ggplot: (8770001690691)>
\end{verbatim}

In this case it appears that the determinant scales exponentially, we
can attempt to model that linearly using \texttt{scikit}, this is significantly
more complex than simply using \textbf{\emph{R}}.
\href{https://towardsdatascience.com/linear-regression-in-6-lines-of-python-5e1d0cd05b8d}{\^{}lrpy}

\begin{minted}[]{python}
  import numpy as np
  import matplotlib.pyplot as plt  # To visualize
  import pandas as pd  # To read data
  from sklearn.linear_model import LinearRegression

  df_slice = df[3:]

  X = df_slice.iloc[:, 0].values.reshape(-1, 1)  # values converts it into a numpy array
  Y = df_slice.iloc[:, 1].values.reshape(-1, 1)  # -1 means that calculate the dimension of rows, but have 1 column
  linear_regressor = LinearRegression()  # create object for the class
  linear_regressor.fit(X, Y)  # perform linear regression
  Y_pred = linear_regressor.predict(X)  # make predictions



  plt.scatter(X, Y)
  plt.plot(X, Y_pred, color='red')
  plt.show()
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{cabe1ce27b757dccdde64927e4d7938241825327.png}
\end{center}

\begin{verbatim}
  array([5.37864677])
\end{verbatim}

\paragraph{Log Transform the Data}
\label{log-transform-the-data}
The \texttt{log} function is actually provided by \texttt{sympy}, to do this quicker
in \texttt{numpy} use \texttt{np.log()}

\begin{minted}[]{python}
  # # pyperclip.copy(df.columns[0])
  # #df['Determinant.Value'] =
  # #[ np.log(val) for val in df['Determinant.Value']]

  df_log = df

  df_log['Determinant.Value'] = [ np.log(val) for val in df['Determinant.Value'] ]

\end{minted}

In order to only have well defined values, consider only after size 3

\begin{minted}[]{python}
  df_plot = df_log[3:]
  df_plot
\end{minted}

\begin{verbatim}
      Matrix.Size  Determinant.Value
  3             3          -2.126234
  4             4          -3.345075
  5             5          -4.013934
  6             6          -4.341001
  7             7          -4.609294
  8             8          -4.850835
  9             9          -5.069048
  10           10          -5.267129
  11           11          -5.448099
  12           12          -5.614501
  13           13          -5.768414
  14           14          -5.911529
  15           15          -6.045230
  16           16          -6.170659
  17           17          -6.288765
  18           18          -6.400347
  19           19          -6.506082
  20           20          -6.606547
  21           21          -6.702237
  22           22          -6.793585
  23           23          -6.880964
  24           24          -6.964704
  25           25          -7.045094
  26           26          -7.122390
  27           27          -7.196822
  28           28          -7.268592
  29           29          -7.337885
\end{verbatim}

A limitation of the \emph{Python} \texttt{plotnine} library (compared to \emph{Ggplot2}
in \textbf{\emph{R}}) is that it isn't possible to round values in the \texttt{aesthetics}
layer, a further limitation with \texttt{pandas} also exists when compared to
\textbf{\emph{R}} that makes rounding data very clusy to do.

In order to round data use the \texttt{numpy} library:

\begin{minted}[]{python}
  import pandas as pd
  import numpy as np
  df_plot['Determinant.Value'] = df_plot['Determinant.Value'].astype(float).round(3)
  df_plot
\end{minted}

\begin{verbatim}
      Matrix.Size  Determinant.Value
  3             3             -2.126
  4             4             -3.345
  5             5             -4.014
  6             6             -4.341
  7             7             -4.609
  8             8             -4.851
  9             9             -5.069
  10           10             -5.267
  11           11             -5.448
  12           12             -5.615
  13           13             -5.768
  14           14             -5.912
  15           15             -6.045
  16           16             -6.171
  17           17             -6.289
  18           18             -6.400
  19           19             -6.506
  20           20             -6.607
  21           21             -6.702
  22           22             -6.794
  23           23             -6.881
  24           24             -6.965
  25           25             -7.045
  26           26             -7.122
  27           27             -7.197
  28           28             -7.269
  29           29             -7.338
\end{verbatim}

\begin{minted}[]{python}
  from plotnine import *


  (ggplot(df_plot[3:], aes(x = 'Matrix.Size', y = 'Determinant.Value')) +
     geom_point(fill= "Blue") +
     labs(x = "Matrix Size", y = "Determinant Value",
          title = "Plot of Determinant Values") +
     theme_bw() +
     stat_smooth(method = 'lm')
  )
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{8e37d51e9bb78ed1d460f8a955f5bf56fafcfca2.png}
\end{center}

\begin{verbatim}
  <ggplot: (8770002281897)>
\end{verbatim}

\begin{minted}[]{python}
  from sklearn.linear_model import LinearRegression

  df_slice = df_plot[3:]

  X = df_slice.iloc[:, 0].values.reshape(-1, 1)  # values converts it into a numpy array
  Y = df_slice.iloc[:, 1].values.reshape(-1, 1)  # -1 means that calculate the dimension of rows, but have 1 column
  linear_regressor = LinearRegression()  # create object for the class
  linear_regressor.fit(X, Y)  # perform linear regression
  Y_pred = linear_regressor.predict(X)  # make predictions



  plt.scatter(X, Y)
  plt.plot(X, Y_pred, color='red')
  plt.show()
\end{minted}

\begin{center}
\includegraphics[width=.9\linewidth]{a0ba199b47f114fb4224946304b31b9f0b555f92.png}
\end{center}

\begin{minted}[]{python}
  m = linear_regressor.fit(X, Y).coef_[0][0]
  b = linear_regressor.fit(X, Y).intercept_[0]

  print("y = " + str(m.round(2)) + "* x" + str(b.round(2)))
\end{minted}

\begin{verbatim}
  y = -0.12* x-4.02
\end{verbatim}

So the model is:

$$
\text{abs}(\text{Det}(M)) = -4n - 0.12
$$

where:

\begin{itemize}
\item \(n\) is the size of the square matrix
\end{itemize}

\paragraph{Largest Percentage Error}
\label{largest-percentage-error}
To find the largest percentage error for \(n \in [30, 50]\) it will be
necessary to calculate the determinants for the larger range,
compressing all the previous steps and calculating the model based on
the larger amount of data:

\begin{minted}[]{python}
  import pandas as pd

  data = {'Matrix.Size': range(30, 50),
          'Determinant.Value': list(map(detMat, range(30, 50)))
  }
  df = pd.DataFrame(data, columns = ['Matrix.Size', 'Determinant.Value'])
  df['Determinant.Value'] = [ np.log(val) for val in df['Determinant.Value']]
  df
  from sklearn.linear_model import LinearRegression


  X = df.iloc[:, 0].values.reshape(-1, 1)  # values converts it into a numpy array
  Y = df.iloc[:, 1].values.reshape(-1, 1)  # -1 means that calculate the dimension of rows, but have 1 column
  linear_regressor = LinearRegression()  # create object for the class
  linear_regressor.fit(X, Y)  # perform linear regression
  Y_pred = linear_regressor.predict(X)  # make predictions

  m = linear_regressor.fit(X, Y).coef_[0][0]
  b = linear_regressor.fit(X, Y).intercept_[0]

  print("y = " + str(m.round(2)) + "* x" + str(b.round(2)))

\end{minted}

\begin{verbatim}
  y = -0.05* x-5.92
\end{verbatim}

\begin{minted}[]{python}
  Y_hat = linear_regressor.predict(X)
  res_per = (Y - Y_hat)/Y_hat
  res_per
\end{minted}

\begin{verbatim}
  array([[-5.41415364e-03],
         [-3.51384602e-03],
         [-1.90798428e-03],
         [-5.74487234e-04],
         [ 5.06726599e-04],
         [ 1.35396448e-03],
         [ 1.98395424e-03],
         [ 2.41201322e-03],
         [ 2.65219545e-03],
         [ 2.71742022e-03],
         [ 2.61958495e-03],
         [ 2.36966444e-03],
         [ 1.97779855e-03],
         [ 1.45336983e-03],
         [ 8.05072416e-04],
         [ 4.09734813e-05],
         [-8.31432011e-04],
         [-1.80517224e-03],
         [-2.87375452e-03],
         [-4.03112573e-03]])
\end{verbatim}

\begin{minted}[]{python}
  max_res = np.max(res_per)
  max_ind = np.where(res_per == max_res)[0][0] + 30

  print("The Maximum Percentage error is " + str(max_res.round(4) * 100) + "% which corresponds to a matrix of size " + str(max_ind))
\end{minted}

\begin{verbatim}
  The Maximum Percentage error is 0.27% which corresponds to a matrix of size 39
\end{verbatim}
\section{What we're looking for}
\label{sec:org7d8535b}

\begin{itemize}
\item Would a reader know what the project is about?
\item Would a reader become interested in the upcoming report?
\item Is it brief but well prepared?
\item Are the major parts or phases sketched out
\end{itemize}


\section{Appendix}
\label{sec:orgb049e2b}

\begin{listing}[htbp]
\begin{minted}[]{python}
  from __future__ import division
  from sympy import *
  x, y, z, t = symbols('x y z t')
  k, m, n = symbols('k m n', integer=True)
  f, g, h = symbols('f g h', cls=Function)
  init_printing()
  init_printing(use_latex='mathjax', latex_mode='equation')


  import pyperclip
  def lx(expr):
      pyperclip.copy(latex(expr))
      print(expr)

  import numpy as np
  import matplotlib as plt

  import time

  def timeit(k):
      start = time.time()
      k
      print(str(round(time.time() - start, 9)) + "seconds")
\end{minted}
\caption{\label{py-env}Preamble for \emph{Python} Environment}
\end{listing}

\subsection{Persian Recursian Examples}
\label{persian-recursion-examples}
\begin{listing}[htbp]
\begin{minted}[]{python}
%config InlineBackend.figure_format = 'svg'
main(5, 9, 1, cx)
\end{minted}
\caption{\label{8-fold-code}Modify listing \ref{persian-recursion-python} to create 9 folds}
\end{listing}



\begin{listing}[htbp]
\begin{minted}[]{python}
%config InlineBackend.figure_format = 'svg'
def cx(l, r, t, b, m):
    new_col = (main.mat[t,l] + main.mat[t,r] +  main.mat[b,l] + main.mat[b,r]-7) % m
    return new_col.astype(int)
main(8, 8, 1, cx)
\end{minted}
\caption{\label{new-func-code}Modify the Function to use \(f(w,x,y,z) = (w + x + y + z - 7) \mod 8\)}
\end{listing}

\begin{figure}[htbp]
\centering
\includesvg[width=9cm]{./persian-recursion-new-func}
\caption{\label{new-func-plot}Output produced by listing \ref{new-func-code} using \(f(w,x,y,z) = (w + x + y + z - 7) \mod 8\)}
\end{figure}


\begin{listing}[htbp]
\begin{minted}[]{python}
%config InlineBackend.figure_format = 'svg'
import numpy as np
def cx(l, r, t, b, m):
    new_col = (main.mat[t,l] + main.mat[t,r]*m +  main.mat[b,l]*(m) + main.mat[b,r]*(m))**1 % m + 1
    return new_col.astype(int)
main(8, 8, 1, cx)
\end{minted}
\caption{\label{new-func2-code}Modify the function to use \(f(w,x,y,z) = (w + 8x + 8y + 8z) \mod 8 + 1\)}
\end{listing}


\begin{figure}[htbp]
\centering
\includesvg[width=9cm]{./persian-recursion-new-func2}
\caption{\label{new-func2-plot}Output produced by listing \ref{new-func2-code} using \(f(w,x,y,z) = (w + 8x + 8y + 8z) \mod 8 + 1\)}
\end{figure}
\subsection{Figures}
\label{sec:org559e186}

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{complex_numbers.png}
\caption{\label{xkcd-complex-numbers}XKCD 2028: Complex Numbers}
\end{figure}
\end{document}
