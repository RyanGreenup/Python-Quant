#+TITLE: Thinking about Problems
:PREAMBLE:
#+OPTIONS: broken-links:auto todo:nil H:9
#+STARTUP: content
#+OPTIONS: tags:not-in-toc d:nil
#+AUTHOR: Ryan Greenup & James Guerra
#+INFOJS_OPT: view:showall toc:3
#+PLOT: title:"Citas" ind:1 deps:(3) type:2d with:histograms set:"yrange [0:]"
#+OPTIONS: tex:t
# #+TODO: TODO IN-PROGRESS WAITING DONE
#+CATEGORY: TAD
:END:
:HTML:
#+INFOJS_OPT: view:info toc:3
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="style.css">
# #+CSL_STYLE: /home/ryan/Templates/CSL/nature.csl
:END:
:R:
#+PROPERTY: header-args:R :session TADMain :dir ./ :cache yes :eval never-export :exports both
# exports: both (or code or whatever)
# results: table (or output or whatever)
:END:
:LATEX:
#+LATEX_HEADER: \IfFileExists{./resources/style.sty}{\usepackage{./resources/style}}{}
#+LATEX_HEADER: \IfFileExists{./resources/referencing.sty}{\usepackage{./resources/referencing}}{}
#+LATEX_HEADER: \addbibresource{../Resources/references.bib}
:END:

* Submission Outline
** Introduction

During preperation for this outline, an article published by the /Mathematical
Association of America/ caught my attention, in which mathematics is referred to
as the /Science of Patterns/ cite:friedMathematicsSciencePatterns2010, this I
feel, frames very well the essence of the research we are looking at in this
project. Mathematics, generally, is primarily concerned with problem solving
(that isn't, however, to say that the problems need to have any
application[fn:rv]), and it's fairly obvious that different strategies work
better for different problems. That's what we want to investigate, Different to
attack a problem, different ways of thinking, different ways of framing
questions.

The central focus of this investigation will be with computer algebra and the
various libraries and packages that exist in the free open source [fn:op] space to solve
and visualise numeric and symbolic problems, these include:

    + Programming Languages and CAS
      - Julia
        + SymEngine
      - Maxima
        + Being the oldest there is probably a lot too learn
      - Julia
      - Reduce
      - Xcas/Gias
      - Python
        + Numpy
        + Sympy
    + Visualisation
      - Makie
      - Plotly
      - GNUPlot


Many problems that look complex upon initial inspection can be solved trivially
by using computer algebra packages and our interest is in the different
approaches that can be taken to /attack/ each problem. Of course however this leads to the question:


#+begin_quote
Can all mathematical problems be solved by some application of some set of rules?
#+end_quote

This is not really a question that we can answer, however, determinism with
respect to systems is appears to make a very good area of investigation with respect to finding ways to deal with problems.

This is not an easy question to answer, however, while investigating this problem



Determinism

Are problems deterministic? can the be broken down into a step by step way? For
example if we /discover all the rules/ can we then simply solve all the problems?

chaos to look at patterns generally to get a deeper understanding of patterns
and problems, loops and recursion generally.

To investigate different ways of thinking about math problems our investigation

laplaces demon

but then heisenberg,

but then chaos and meh.

** Preliminary Problems
We did a tonne of these but this one really illustrates the sort of things that we're looking at.
*** Iteration and Recursion
   :PROPERTIES:
   :CUSTOM_ID: series-and-recursion
   :END:
To illustrate an example of different ways of thinking about a problem, consider the series shown in eqref:eq:rec-ser[fn:pja] :

\begin{align}
    g\left( k \right) &=  \frac{\sqrt{2} }{2} \cdot   \frac{\sqrt{2+  \sqrt{3}}  }{3} \frac{\sqrt{2 +  \sqrt{3 +  \sqrt{4} } } }{4} \cdot  \ldots \frac{\sqrt{2 +  \sqrt{3 +  \ldots +  \sqrt{k} } } }{k} \label{eq:rec-ser}
\end{align}

let's modify this for the sake of discussion:

\begin{align}
h\left( k \right) = \frac{\sqrt{2}  }{2} \cdot  \frac{\sqrt{3 +  \sqrt{2} } }{3} \cdot  \frac{\sqrt{4 +  \sqrt{3 +  \sqrt{2} } } }{4} \cdot  \ldots \cdot  \frac{\sqrt{k +  \sqrt{k - 1 +  \ldots \sqrt{3 + \sqrt{2}  } } } }{k} \label{eq:rec-ser-mod}
\end{align}

The function $h$ can be expressed by the series:

$$\begin{aligned}
h\left( k \right) = \prod^k_{i = 2} \left( \frac{f_i}{i}  \right)  \quad : \quad f_i = \sqrt{i +  f_{i - 1}}, \enspace f_{1} = 1
\end{aligned}$$

Within /Python/, it isn't difficult to express $h$, the series can be expressed with recursion as shown in listing [[rec-one]], this is a very natural way to define series and sequences and is consistent with familiar mathematical thought and notation. Individuals more familiar with programming than analysis may find it more comfortable to use an iterator as shown in listing [[it-one]].

#+NAME: rec-one
#+CAPTION: Solving eqref:eq:rec-ser-mod using recursion.
#+BEGIN_SRC python
################################################################################
from sympy import *
def h(k):
    if k > 2:
        return f(k) * f(k-1)
    else:
        return 1

def f(i):
    expr = 0
    if i > 2:
        return sqrt(i + f(i -1))
    else:
        return 1
#+END_SRC


#+NAME: it-one
#+CAPTION: Solving eqref:eq:rec-ser-mod by using a ~for~ loop.
#+BEGIN_SRC python
  from sympy import *
  def h(k):
      k = k + 1 # OBOB
      l = [f(i) for i in range(1,k)]
      return prod(l)

  def f(k):
      expr = 0
      for i in range(2, k+2):
          expr = sqrt(i + expr, evaluate=False)
      return expr/(k+1)
#+END_SRC

Any function that can be defined by using iteration, can always be defined via
recursion and vice versa,
cite:bohmReducingRecursionIteration1988,bohmReducingRecursionIteration1986
see also
cite:smolarskiMath60Notes2000,IterationVsRecursion2016

there is, however, evidence to suggest that recursive functions are easier for people to understand cite:benanderEmpiricalAnalysisDebugging2000 . Although independent research has shown that the specific language chosen can have a bigger effect on how well recursive as opposed to iterative code is understood cite:sinhaCognitiveFitEmpirical1992.

The relevant question is which method is often more appropriate, generally the process for
determining which is more appropriate is to the effect of:

1. Write the problem in a way that is easier to write or is more
   appropriate for demonstration
2. If performance is a concern then consider restructuring in favour of iteration
   - For interpreted languages such */R/* and /Python/, loops are usually
     faster, because of the overheads involved in creating functions
     cite:smolarskiMath60Notes2000 although there may be exceptions to this and
     I'm not sure if this would be true for compiled languages such as /Julia/,
     /Java/, */C/* etc.

**** Some Functions are more difficult to express with Recursion in
:PROPERTIES:
    :CUSTOM_ID: some-functions-are-more-difficult-to-express-with-recursion-in-python
    :END:

Attacking a problem recursively isn't always the best approach, consider the function $g\left( k \right)$ from eqref:eq:rec-ser:


\begin{align}
    g\left( k \right) &=  \frac{\sqrt{2} }{2} \cdot   \frac{\sqrt{2+  \sqrt{3}}  }{3} \frac{\sqrt{2 +  \sqrt{3 +  \sqrt{4} } } }{4} \cdot  \ldots \frac{\sqrt{2 +  \sqrt{3 +  \ldots +  \sqrt{k} } } }{k} \nonumber \\
    &=  \prod^k_{i = 2} \left( \frac{f_i}{i}  \right) \quad : \quad f_{i} = \sqrt{i +  f_{i+1}} \nonumber
\end{align}

Observe that the difference between eqref:eq:rec-ser and eqref:eq:rec-ser-mod is
that the sequence essentially /looks/ forward, not back. To solve using a =for=
loop, this distinction is a non-concern because the list can be reversed using a built-in
such as =rev=, =reversed= or =reverse= in /Python/, */R/* and /Julia/
respectively, which means the same expression can be implemented.

To implement recursion however, the series needs to be restructured and this can become a little clumsy, see eqref:eq:clumsy:

\begin{align}
    g\left( k \right) &=  \prod^k_{i = 2} \left( \frac{f_i}{i}  \right) \quad : \quad f_{i} = \sqrt{\left( k- i \right)  +  f_{k - i - 1}} \label{eq:clumsy}
\end{align}

Now the function could be performed recursively in /Python/ in a similar
way as shown in listing [[rec-two]], but it's also significantly more confusing because the $f$ function now has $k$ as a parameter and this is only made significantly more complicated by the variable scope of functions across common languages used in Mathematics and Data science such as ~bash~, /Python/, */R/* and /Julia/ (see section [[#variable-scope-nested]]).


If however, the =for= loop approach was implemented, as shown in listing
[[iter-two]], the function would not significantly change, because the =reversed()= function can be
used to flip the list around.

What this demonstrates is that taking a different approach to simply describing
this function can lead to big differences in the complexity involved in solving
this problem.

#+NAME: rec-two
#+CAPTION: Using Recursion to Solve eqref:eq:rec-ser
#+BEGIN_SRC python
from sympy import *
def h(k):
    if k > 2:
        return f(k, k) * f(k, k-1)
    else:
        return 1

def f(k, i):
    if k > i:
        return 1
    if i > 2:
        return sqrt((k-i) + f(k, k - i -1))
    else:
        return 1
#+END_SRC


#+NAME: iter-two
#+CAPTION: Using Iteration to Solve eqref:eq:rec-ser
#+BEGIN_SRC python
from sympy import *
def h(k):
    k = k + 1 # OBOB
    l = [f(i) for i in range(1,k)]
    return prod(l)

def f(k):
    expr = 0
    for i in reversed(range(2, k+2)):
        expr = sqrt(i + expr, evaluate=False)
    return expr/(k+1)
#+END_SRC

**** TODO Variable Scope of Nested Functions
:PROPERTIES:
:CUSTOM_ID: variable-scope-nested
:END:

** TODO Fibonacci Sequence
This pops up all the time in natural sequences and fractals so we'll deal with it now
*** TODO Computational Approach
   :PROPERTIES:
   :CUSTOM_ID: define-the-fibonacci-numbers
   :END:
The /Fibonacci/ Numbers are given by:

\begin{align}
F_n = F_{n-1} + F_{n-2} \label{eq:fib-def}
\end{align}

This type of recursive relation can be expressed in /Python/ by using recursion,
as shown in listing [[fib-rec-0]], however using this function will reveal that it
is extraordinarily slow, as shown in listing [[time-slow]], this is because the
results of the function are not cached and every time the function is called
every value is recalculated[fn:cch], meaning that the workload scales in
exponential as opposed to polynomial time.

The ~functools~ library for python includes the ~@functools.lru_cache~ decorator
which will modify a defined function to cache results in memory
cite:FunctoolsHigherorderFunctions, this means that the recursive function will
only need to calculate each result once and it will hence scale in polynomial
time, this is implemented in listing [[fib-cache]].


#+NAME: fib-rec-0
#+CAPTION: Defining the /Fibonacci Sequence/ eqref:eq:fib-def using Recursion
#+BEGIN_SRC python
  def rec_fib(k):
      if type(k) is not int:
          print("Error: Require integer values")
          return 0
      elif k == 0:
          return 0
      elif k <= 2:
          return 1
      return rec_fib(k-1) + rec_fib(k-2)
#+END_SRC

#+NAME: time-slow
#+CAPTION: Using the function from listing [[fib-rec-0]] is quite slow.
#+BEGIN_SRC python
  start = time.time()
  rec_fib(35)
  print(str(round(time.time() - start, 3)) + "seconds")

## 2.245seconds
#+END_SRC


#+NAME: fib-cache
#+CAPTION: Caching the results of the function previously defined [[time-slow]]
#+BEGIN_SRC python
  from functools import lru_cache
 
  @lru_cache(maxsize=9999)
  def rec_fib(k):
      if type(k) is not int:
          print("Error: Require Integer Values")
          return 0
      elif k == 0:
          return 0
      elif k <= 2:
          return 1
      return rec_fib(k-1) + rec_fib(k-2)


start = time.time()
rec_fib(35)
print(str(round(time.time() - start, 3)) + "seconds")
## 0.0seconds
#+END_SRC

#+BEGIN_SRC python
  start = time.time()
  rec_fib(6000)
  print(str(round(time.time() - start, 9)) + "seconds")

## 8.3923e-05seconds
#+END_SRC

Restructuring the problem to use iteration will allow for even greater performance as demonstrated by finding $F_{10^{6}}$ in listing [[fib-iter]]. Using a compiled language such as /Julia/ however would be thousands of times faster still, as demonstrated in listing [[julia-fib]].



#+NAME: fib-iter
#+CAPTION: Using Iteration to Solve the Fibonacci Sequence
#+BEGIN_SRC python
  def my_it_fib(k):
      if k == 0:
          return k
      elif type(k) is not int:
          print("ERROR: Integer Required")
          return 0
      # Hence k must be a positive integer

      i  = 1
      n1 = 1
      n2 = 1

      # if k <=2:
      #     return 1

      while i < k:
         no = n1
         n1 = n2
         n2 = no + n2
         i = i + 1
      return (n1)

  start = time.time()
  my_it_fib(10**6)
  print(str(round(time.time() - start, 9)) + "seconds")

 ## 6.975890398seconds
#+END_SRC

#+NAME: julia-fib
#+CAPTION: Using Julia with an iterative approach to solve the 1 millionth fibonacci number
#+begin_src julia :results output
function my_it_fib(k)
    if k == 0
        return k
    elseif typeof(k) != Int
        print("ERROR: Integer Required")
        return 0
    end
    # Hence k must be a positive integer

    i  = 1
    n1 = 1
    n2 = 1

    # if k <=2:
    #     return 1
    while i < k
       no = n1
       n1 = n2
       n2 = no + n2
       i = i + 1
    end
    return (n1)
end

@time my_it_fib(10^6)

##  my_it_fib (generic function with 1 method)
##    0.000450 seconds
#+end_src

In this case however an analytic solution can be found by relating discrete
mathematical problems to continuous ones as discussed below at section [[#exp-gen-function]].
*** Exponential Generating Functions
:PROPERTIES:
:CUSTOM_ID: exp-gen-func-fib-seq
:END:
**** Motivation
    :PROPERTIES:
    :CUSTOM_ID: motivation
    :END:

Consider the /Fibonacci Sequence/ from eqref:eq:fib-def:


\begin{align}
    a_{n}&= a_{n - 1} + a_{n - 2} \nonumber \\
\iff a_{n+  2} &= a_{n+  1} +  a_n \label{eq:fib-def-shift}
\end{align}


from observation, this appears similar in structure to the following /ordinary
differential equation/, which would be fairly easy to deal with:


\begin{align*}
f''\left( x \right)- f'\left( x \right)- f\left( x \right)=  0
\end{align*}

By ODE Theory we have $y \propto e^{m_{i}x}, \enspace i = 1, 2$:

\begin{align*}
f\left( x \right)= e^{mx} = \sum^{\infty}_{n= 0}   \left[ r^{m} \frac{x^n}{n!} \right]
\end{align*}

So using some sort of a transformation involving a power series may help to
relate the discrete problem back to a continuous one.

**** Example
    :PROPERTIES:
    :CUSTOM_ID: solving-the-sequence
    :END:

Consider using the following generating function, (the derivative of the
generating function as in eqref:eq:exp-gen-def-2 and eqref:eq:exp-gen-def-3 is
provided in section [[#Derivative-exp-gen-function]])




\begin{align}
    f\left( x \right) &=  \sum^{\infty}_{n= 0}   \left[ a_{n} \cdot  \frac{x^n}{n!} \right]   \label{eq:exp-gen-def-1} \\
 \implies   f'\left( x \right) &=  \sum^{\infty}_{n= 0}   \left[ a_{n+1} \cdot  \frac{x^n}{n!} \right]   \label{eq:exp-gen-def-2} \\
\implies    f''\left( x \right) &=  \sum^{\infty}_{n= 0}   \left[ a_{n+2} \cdot  \frac{x^n}{n!} \right]   \label{eq:exp-gen-def-3}
\end{align}


So the recursive relation from eqref:eq:fib-def-shift  could be expressed :


\begin{align*}
a_{n+  2}    &= a_{n+  1} +  a_{n}\\
\frac{x^n}{n!}   a_{n+  2}    &= \frac{x^n}{n!}\left( a_{n+  1} +  a_{n}  \right)\\
\sum^{\infty}_{n= 0} \left[ \frac{x^n}{n!}   a_{n+  2} \right]        &= \sum^{\infty}_{n= 0}   \left[ \frac{x^n}{n!} a_{n+  1} \right]  + \sum^{\infty}_{n= 0}   \left[ \frac{x^n}{n!} a_{n}  \right]  \\
\end{align*}

And hence by applying eqref:eq:exp-gen-def-1:

\begin{align}
f''\left( x \right) &= f'\left( x \right)+  f\left( x \right)
\end{align}


Using the theory of higher order linear differential equations with
constant coefficients it can be shown:


\begin{align*}
f\left( x \right)= c_1 \cdot  \mathrm{exp}\left[ \left( \frac{1- \sqrt{5} }{2} \right)x \right] +  c_2 \cdot  \mathrm{exp}\left[ \left( \frac{1 +  \sqrt{5} }{2} \right) \right]
\end{align*}


By equating this to the power series:


\begin{align*}
f\left( x \right)&= \sum^{\infty}_{n= 0}   \left[ \left( c_1\left( \frac{1- \sqrt{5} }{2} \right)^n +  c_2 \cdot  \left( \frac{1+ \sqrt{5} }{2} \right)^n \right) \cdot  \frac{x^n}{n} \right]
\end{align*}


Now given that:


\begin{align*}
f\left( x \right)= \sum^{\infty}_{n= 0}   \left[ a_n \frac{x^n}{n!} \right]
\end{align*}


We can conclude that:


\begin{align*}
a_n = c_1\cdot  \left( \frac{1- \sqrt{5} }{2} \right)^n +  c_2 \cdot  \left( \frac{1+  \sqrt{5} }{2} \right)
\end{align*}


By applying the initial conditions:


\begin{align*}
a_0= c_1 +  c_2  \implies  c_1= - c_2\\
a_1= c_1 \left( \frac{1+ \sqrt{5} }{2} \right) -  c_1 \frac{1-\sqrt{5} }{2}  \implies  c_1 = \frac{1}{\sqrt{5} }
\end{align*}


And so finally we have the solution to the /Fibonacci Sequence/ ref:eq:fib-def-shift:


\begin{align}
    a_n &= \frac{1}{\sqrt{5} } \left[ \left( \frac{1+  \sqrt{5} }{2}  \right)^n -  \left( \frac{1- \sqrt{5} }{2} \right)^n \right] \nonumber \\
&= \frac{\varphi^n - \psi^n}{\sqrt{5} } \nonumber\\
&=\frac{\varphi^n -  \psi^n}{\varphi - \psi} \label{eq:fib-sol}
\end{align}


where:

- $\varphi = \frac{1+ \sqrt{5} }{2} \approx 1.61\ldots$
- $\psi = 1-\varphi = \frac{1- \sqrt{5} }{2} \approx 0.61\ldots$

**** Derivative of the Exponential Generating Function
    :PROPERTIES:
    :CUSTOM_ID: Derivative-exp-gen-function
    :END:
    Differentiating the exponential generating function has the effect of shifting the sequence to the backward: cite:lehmanReadingsMathematicsComputer2010

\begin{align}
    f\left( x \right) &= \sum^{\infty}_{n= 0}   \left[ a_n \frac{x^n}{n!} \right] \label{eq:exp-pow-series} \\
f'\left( x \right)) &= \frac{\mathrm{d} }{\mathrm{d} x}\left( \sum^{\infty}_{n= 0}   \left[ a_n \frac{x^n}{n!} \right]  \right) \nonumber \\
&= \frac{\mathrm{d}}{\mathrm{d} x} \left( a_0 \frac{x^0}{0!} +  a_1 \frac{x^1}{1!} +  a_2 \frac{x^2}{2!}+  a_3 \frac{x^3}{3! } +  \ldots \frac{x^k}{k!} \right) \nonumber \\
&= \sum^{\infty}_{n= 0}   \left[ \frac{\mathrm{d} }{\mathrm{d} x}\left( a_n \frac{x^n}{n!} \right) \right] \nonumber \\
&= \sum^{\infty}_{n= 0}   {\left[{ \frac{a_n}{{\left({ n- 1 }\right)!}} } x^{n- 1}  \right]} \nonumber \\
\implies f'(x) &= \sum^{\infty}_{n= 0}   {\left[{ \frac{x^n}{n!}a_{n+  1} }\right]} \label{eq:exp-pow-series-sol}
\end{align}

***** Inductive Proof                                                       :James:
This can be shown for all derivatives by way of induction, for

\begin{align}
f^{(k)}\left(x\right) = \sum_{n=0}^\infty\frac{a_{n+k}\cdot x^n}{n!} \quad \text{for}~k \ge 0
\end{align}

Assume that. $f^{(k)}\left(x\right) = \sum_{n=0}^\infty\frac{a_{n+k}\cdot x^n}{n!}$

Using this assumption, prove for the next element $k+1$\\

We need $f^{(k+1)}(x) = \sum_{n=0}^\infty\frac{a_{n+k+1}\cdot x^n}{n!}$

\begin{align*}
    \text{LHS} &= f^{(k+1)}(x)\\
    &= \frac{\mathrm{d}}{\mathrm{d}x}\left(f^{(k)}(x)\right)\\
    &= \frac{\mathrm{d}}{\mathrm{d}x}\left(\sum_{n=0}^\infty\frac{a_{n+k}\cdot x^n}{n!}\right)\quad \text{by assumption}\\
    &= \sum_{n=0}^\infty\frac{a_{n+k}\cdot n\cdot x^{n-1}}{n!}\\
    &= \sum_{n=1}^\infty\frac{a_{n+k}\cdot x^{n-1}}{(n-1)!}\\
    &= \sum_{n=0}^\infty\frac{a_{n+k+1}\cdot x^{n}}{n!}\\
    &= \text{RHS}
\end{align*}

Thus, if the derivative of the series shown in eqref:eq:exp-gen-def-1 shifts the
sequence across, then every derivative thereafter does so as well, because the
first derivative has been shown to express this property
eqref:eq:exp-pow-series-sol, all derivates will.


**** TODO Homogeneous Proof
An equation of the form:

\begin{align}
\sum^{n}_{i=0} \left[ c_{i} \cdot f^{(i)}(x) \right] = 0 \label{eq:hom-ode}
\end{align}

is said to be a homogenous linear ODE: [[cite:zillDifferentialEquations2009a][Ch. 2]]

- Linear :: because the equation is linear with respect to $f(x)$
- Ordinary :: because there are no partial derivatives (e.g. $\frac{\partial }{\partial x}{\left({ f{\left({ x }\right)} }\right)}$  )
- Differential :: because the derivates of the function are concerned
- Homogenous :: because the */RHS/* is 0
  - A non-homogeous equation would have a non-zero RHS

There will be $k$ solutions to a $k^{\mathrm{th}}$ order linear ODE, each may be summed to produce a superposition which will also be a solution to the equation, [[cite:zillDifferentialEquations2009a][Ch. 4]]  this will be considered as the desired complete solution (and this will be shown to be the only solution for the recurrence relation eqref:eq:recurrence-relation-def). These $k$ solutions will be in one of two forms:

1. $f(x)=c_{i} \cdot e^{m_{i}x}$
2. $f(x)=c_{i} \cdot x^{j}\cdot e^{m_{i}x}$

where:

- $\sum^{k}_{i=0}\left[  c_{i}m^{k-i} \right] = 0$
  - This is referred to the characteristic equation of the recurrence relation or ODE cite:levinSolvingRecurrenceRelations2018
- $\exists i,j \in \mathbb{Z}^{+} \cap \left[0,k\right]$
  - These is often referred to as repeated roots cite:levinSolvingRecurrenceRelations2018,zillMatrixExponential2009 with a multiplicity corresponding to the number of repetitions of that root [[cite:nicodemiIntroductionAbstractAlgebra2007][\textsection 3.2]]

***** Unique Roots of Characteristic Equation
:PROPERTIES:
:CUSTOM_ID: uniq-roots-recurrence
:END:
****** Example
An example of a recurrence relation with all unique roots is the fibonacci sequence, as described in section [[#solving-the-sequence]].
****** Proof
Consider the linear recurrence relation eqref:eq:recurrence-relation-def:

\begin{align}
\sum^{n}_{i= 0}   \left[ c_i \cdot  a_i \right] = 0, \quad \exists c \in
\mathbb{R}, \enspace \forall i<k\in\mathbb{Z}^+ \nonumber \label{eq:recurrence-relation-def}
\end{align}
This implies:


\begin{align}
    \sum^{\infty}_{n= 0}   \left[ \sum^{k}_{i= 0}   \left[ \frac{x^n}{n!} c_i a_n \right]  \right]  &= 0 \\
    \sum^{\infty}_{n= 0}    \sum^{k}_{i= 0}    \frac{x^n}{n!} c_i a_n    &= 0 \\
        \sum^{k}_{i= 0} c_i \sum^{\infty}_{n= 0}    \frac{x^n}{n!}  a_n    &= 0
\end{align}

By implementing the exponential generating function as shown in
eqref:eq:exp-gen-def-1, this provides:

\begin{align}
   \sum^{k}_{i= 0}   \left[ c_i f^{\left( i \right)}\left( x \right) \right]
\end{align}


Now assume that the solution exists and all roots of the characteristic polynomial are unique (i.e. the solution is of the form $f{\left({ x }\right)} \propto e^{m_i x}: \quad m_i \neq m_j \forall i\neq j$), this implies that  [[cite:zillDifferentialEquations2009a][Ch. 4]] :

\begin{align}
    f{\left({ x }\right)} = \sum^{k}_{i= 0}   {\left[{ k_i e^{m_i x} }\right]}, \quad \exists m,k \in \mathbb{C} \nonumber
\end{align}

This can be re-expressed in terms of the exponential power series, in order to relate the solution of the function $f{\left({ x }\right)}$ back to a solution of the sequence $a_n$, (see section [[#prove-exp-power-series]] for a derivation of the exponential power series):

\begin{align}
    \sum^{k}_{i= 0}   {\left[{ k_i e^{m_i x}  }\right]}  &= \sum^{k}_{i= 0}   {\left[{ k_i \sum^{\infty}_{n= 0}   \frac{{\left({ m_i x }\right)}^n}{n!}  }\right]}  \nonumber \\
							 &= \sum^{k}_{i= 0}  \sum^{\infty}_{n= 0}   k_i m_i^n \frac{x^n}{n!} \nonumber\\
							 &=    \sum^{\infty}_{n= 0} \sum^{k}_{i= 0}   k_i m_i^n \frac{x^n}{n!} \nonumber \\
							 &= \sum^{\infty}_{n= 0} {\left[{ \frac{x^n}{n!}  \sum^{k}_{i=0}   {\left[{ k_im^n_i }\right]}  }\right]}, \quad \exists k_i \in \mathbb{C}, \enspace \forall i \in \mathbb{Z}^+\cap {\left[{ 1, k }\right]}     \label{eq:unique-root-sol-power-series-form}
\end{align}

Recall the definition of the generating function from ref:eq:exp-gen-def-proof, by relating this to eqref:eq:unique-root-sol-power-series-form:

\begin{align}
    f{\left({ x }\right)} &= \sum^{\infty}_{n= 0}   {\left[{  \frac{x^n}{n!} a_n }\right]} \nonumber \\
&= \sum^{\infty}_{n= 0} {\left[{ \frac{x^n}{n!}  \sum^{k}_{i=0}   {\left[{ k_im^n_i }\right]}  }\right]}  \nonumber \\
      \implies  a_n &= \sum^{k}_{n= 0} {\left[{ k_im_i^n }\right]}     \nonumber \\ \nonumber
\square
\end{align}

This can be verified by the fibonacci sequence as shown in section [[#solving-the-sequence]], the solution to the characteristic equation is $m_1 = \varphi, m_2 = {\left({ 1-\varphi }\right)}$ and the corresponding solution to the linear ODE and recursive relation are:

\begin{alignat}{4}
    f{\left({ x }\right)} &= &c_1 e^{\varphi x} +  &c_2 e^{{\left({ 1-\varphi }\right)} x}, \quad &\exists c_1, c_2 \in \mathbb{R} \subset \mathbb{C} \nonumber \\
    \iff  a_n &= &k_1 n^{\varphi} +  &k_2 n^{1- \varphi}, &\exists k_1, k_2 \in \mathbb{R} \subset \mathbb{C} \nonumber
\end{alignat}

***** Repeated Roots of Characteristic Equation
:PROPERTIES:
:CUSTOM_ID: rep-roots-recurrence
:END:
****** Example
Consider the following recurrence relation:

\begin{align}
    a_n -  10a_{n+ 1} +  25a_{n+  2}&= 0 \label{eq:hom-repeated-roots-recurrence} \\
    \implies  \sum^{\infty}_{n= 0}   {\left[{ a_n \frac{x^n}{n!} }\right]} - 10 \sum^{\infty}_{n= 0}   {\left[{ \frac{x^n}{n!}+    }\right]} + 25 \sum^{\infty}_{n= 0 }   {\left[{  a_{n+  2 }\frac{x^n}{n!} }\right]}&= 0 \nonumber
\end{align}

By applying the definition of the exponential generating function at eqref:eq:exp-gen-def-1 :

\begin{align}
    f''{\left({ x }\right)}- 10f'{\left({ x }\right)}+  25f{\left({ x }\right)}= 0 \nonumber \label{eq:rep-roots-func-ode}
\end{align}

By implementing the already well-established theory of linear ODE's, the characteristic equation for eqref:eq:rep-roots-func-ode can be expressed as:

\begin{align}
    m^2- 10m+  25 = 0 \nonumber \\
    {\left({ m- 5 }\right)}^2 = 0 \nonumber \\
    m= 5 \label{eq:rep-roots-recurrence-char-sol}
\end{align}

Herein lies a complexity, in order to solve this, the solution produced from eqref:eq:rep-roots-recurrence-char-sol can be used with the /Reduction of Order/ technique to produce a solution that will be of the form [[cite:zillMatrixExponential2009][\textsection 4.3]].

\begin{align}
    f{\left({ x }\right)}= c_1e^{5x} +  c_2 x e^{5x} \label{eq:rep-roots-ode-sol}
\end{align}

eqref:eq:rep-roots-ode-sol can be expressed in terms of the exponential power series in order to try and relate the solution for the function back to the generating function,
observe however the following power series identity (TODO Prove this in section [[#prove-ext-exp-power-series-rep-roots]]):

\begin{align}
    x^ke^x &= \sum^{\infty}_{n= 0}   {\left[{ \frac{x^n}{{\left({ n- k }\right)}!} }\right]}, \quad \exists k \in \mathbb{Z}^+ \label{eq:uniq-roots-pow-series-ident}
\end{align}

by applying identity eqref:eq:uniq-roots-pow-series-ident to equation eqref:eq:rep-roots-ode-sol

\begin{align}
    \implies  f{\left({ x }\right)} &= \sum^{\infty}_{n= 0}   {\left[{ c_1 \frac{{\left({ 5x }\right)}^n}{n!} }\right]}  +  \sum^{\infty}_{n= 0}   {\left[{ c_2 n \frac{{\left({ 5x^n }\right)}}{n{\left({ n-1 }\right)}!} }\right]} \nonumber \\
 &= \sum^{\infty}_{n= 0}   {\left[{ \frac{x^n}{n!} {\left({ c_{1}5^n +  c_2 n 5^n   }\right)} }\right]} \nonumber
\end{align}

Given the defenition of the exponential generating function from eqref:eq:exp-gen-def-1

\begin{align}
    f{\left({ x }\right)}&=     \sum^{\infty}_{n= 0}   {\left[{ a_n \frac{x^n}{n!} }\right]} \nonumber \\
    \iff a_n &= c_{15}^n +  c_2n_5^n \nonumber \\ \nonumber
    \ \nonumber \\
    \square \nonumber
\end{align}
****** TODO Proof
In order to prove the the solution for a $k^{\mathrm{th}}$ order recurrence relation with $k$ repeated


Consider a recurrence relation of the form:

\begin{align}
     \sum^{k}_{n= 0}   {\left[{ c_i a_n }\right]}  = 0 \nonumber \\
      \implies  \sum^{\infty}_{n= 0}   \sum^{k}_{i= 0}   c_i a_n \frac{x^n}{n!} = 0 \nonumber \\
      \sum^{k}_{i= 0}   \sum^{\infty}_{n= 0}   c_i a_n \frac{x^n}{n!} \nonumber
\end{align}

By substituting for the value of the generating function (from eqref:eq:exp-gen-def-1):

\begin{align}
    \sum^{k}_{i= 0}   {\left[{ c_if^{{\left({ k }\right)}}  {\left({ x }\right)}    }\right]} \label{eq:gen-form-rep-roots-ode}
\end{align}

Assume that eqref:eq:gen-form-rep-roots-ode corresponds to a charecteristic polynomial with only 1 root of multiplicity $k$, the solution would hence be of the form:

\begin{align}
			 & \sum^{k}_{i= 0}   {\left[{ c_i m^i }\right]} = 0 \wedge m=B, \enspace  \exists! B \in \mathbb{C} \nonumber \\
 \implies      f{\left({ x }\right)}&= \sum^{k}_{i= 0}   {\left[{ x^i A_i e^{mx} }\right]}, \quad \exists A \in \mathbb{C}^+, \enspace \forall i \in {\left[{ 1,k }\right]} \cap \mathbb{N}  \label{eq:sol-rep-roots-ode} \\
\end{align}

If we assume that (see section [[#power-series-comb]]):

\begin{align}
k \in \mathbb{Z} \implies x^k e^x = \sum^{\infty}_{n= 0} {\left[{ \frac{x^n}{{\left({ n- k }\right)}!} }\right]}     \label{eq:power-series-comb}
\end{align}

By applying this to eqref:eq:sol-rep-roots-ode :

\begin{align}
f{\left({ x }\right)}&=     \sum^{k}_{i= 0}   {\left[{ A_i \sum^{\infty}_{n= 0}   {\left[{ \frac{{\left({ x m }\right)}^n}{{\left({ n- i }\right)}!} }\right]}  }\right]} \nonumber \\
&=     \sum^{\infty}_{n= 0}   {\left[{ \sum^{k}_{i=0} {\left[{ \frac{x^n}{n!}  \frac{n!}{{\left({ n- i }\right)}} A_i m^n }\right]}       }\right]} # \\
&=     \sum^{\infty}_{n= 0} {\left[{ \frac{x^n}{n!}   \sum^{k}_{i=0} {\left[{  \frac{n!}{{\left({ n- i }\right)}} A_i m^n }\right]}       }\right]}
\end{align}

Recall the generating function that was used to get ref:eq:gen-form-rep-roots-ode:

\begin{align}
f{\left({ x }\right)}&= \sum^{\infty}_{n= 0}   {\left[{ a_n \frac{x^n}{n!} }\right]}      \nonumber \\
 \implies  a_n &= \sum^{k}_{i= 0}   {\left[{ A_i \frac{n!}{{\left({ n- i }\right)}!} m^n  }\right]} \nonumber \\
 &= \sum^{k}_{i= 0}   {\left[{ m^n A_i \prod_{0}^{k} {\left[{ n- {\left({ i- 1 }\right)} }\right]}   }\right]}
& \intertext{$\because \enspace i \leq k$} \notag \\
 &= \sum^{k}_{i= 0} {\left[{ A_i^* m^n n^i }\right]}, \quad \exists A_i \in \mathbb{C}, \enspace \forall i\leqk \in \mathbb{Z}^+ \nonumber \\
\ \nonumber \\
\square \nonumber
\end{align}



***** TODO General Proof
:PROPERTIES:
:CUSTOM_ID: general-gen-func-proof
:END:
In sections [[#uniq-roots-recurrence]] and [[*Unique Roots of Characteristic Equation]]
it was shown that a recurrence relation can be related to an ODE and then that
solution can be transformed to provide a solution for the recurrence relation,
when the charecteristic polynomial has either complex roots or 1 repeated root.
Generally the solution to a linear ODE will be a superposition of solutions for
each root, repeated or unique and so a goal of our research will be to put this
together to find a general solution for homogenous linear recurrence relations.
****** Power Series
:PROPERTIES:
:CUSTOM_ID: power-series-comb
:END:
A further goal will be to prove eqref:eq:power-series-comb for the case of the
integers.

Sketching out an approach for this:

- Use the Generating function to get an ODE
- The ODE will have a solution that is a combination of the above two forms
- The solution will translate back to a combination of both above forms

*** Fibonacci Sequence and the Golden Ratio
:PROPERTIES:
:CUSTOM_ID: fib-golden-ratio-proof
:END:
The /Fibonacci Sequence/ is actually very interesting, observe that the ratios of the terms converge to the /Golden Ratio/:

\begin{align*}
    F_n &= \frac{\varphi^n-\psi^n}{\varphi-\psi} = \frac{\varphi^n-\psi^n}{\sqrt 5} \\
    \iff \frac{F_{n+1}}{F_n}	&= \frac{\varphi^{n+ 1} - \psi^{n+  1}}{\varphi^{n} - \psi^{n}} \\
    \iff \lim_{n \rightarrow \infty}\left[ \frac{F_{n+1}}{F_n} \right]	&= \lim_{n \rightarrow \infty}\left[ \frac{\varphi^{n+ 1} - \psi^{n+  1}}{\varphi^{n} - \psi^{n}} \right] \\
&= \frac{\varphi^{n+ 1} -\lim_{n \rightarrow \infty}\left[ \psi^{n +  1} \right] }{\varphi^{n} - \lim_{n \rightarrow \infty}\left[ \psi^n \right] } \\
\text{because $\mid \psi \mid < 0$ $n \rightarrow \infty \implies \psi^{n} \rightarrow 0$:} \\
&= \frac{\varphi^{n+  1} -  0}{\varphi^{n} -  0} \\
&= \varphi
\end{align*}

We'll come back to this later on when looking at spirals and fractals.

We hope to demonstrate this relationship between the ratio of successive terms
of the fibonacci sequence without relying on ODEs and generating functions and
by instead using limits and the /Monotone Convergence Theorem/, the hope being that this will reveal deeper underlying relationships between the /Fibonacci Sequence/ and the /Golden Ratio/ given that the both appear to occur in patterns observed in nature.

This can also be shown by using analysis, let $L=\lim_{n \rightarrow \infty}
\left[ \frac{F_{n+1}}{F_{n}} \right], then:

* TODO What we're looking for

- Would a reader know what the project is about?
- Would a reader become interested in the upcoming report?
- Is it brief but well prepared?
- Are the major parts or phases sketched out


* Appendix

#+NAME: py-env
#+CAPTION: Preamble for /Python/ Environment
#+BEGIN_SRC python
  from __future__ import division
  from sympy import *
  x, y, z, t = symbols('x y z t')
  k, m, n = symbols('k m n', integer=True)
  f, g, h = symbols('f g h', cls=Function)
  init_printing()
  init_printing(use_latex='mathjax', latex_mode='equation')


  import pyperclip
  def lx(expr):
      pyperclip.copy(latex(expr))
      print(expr)

  import numpy as np
  import matplotlib as plt

  import time

  def timeit(k):
      start = time.time()
      k
      print(str(round(time.time() - start, 9)) + "seconds")
#+END_SRC

** Persian Recursian Examples
:PROPERTIES:
:CUSTOM_ID: persian-recursion-examples
:END:


#+NAME: 8-fold-code
#+CAPTION: Modify listing [[persian-recursion-python]] to create 9 folds
#+BEGIN_SRC ipython :exports output :results raw :eval never-export :session persian-recursion :eval never-export :ipyfile ./persian-recursion-large.svg
%config InlineBackend.figure_format = 'svg'
main(5, 9, 1, cx)
#+END_SRC



#+attr_html: :width 400px
#+attr_latex: :width 9cm
#+NAME: 8-fold-plot
#+CAPTION: Output produced by listing [[persian-recursion-python]] with 9 folds

#+NAME: new-func-code
#+CAPTION: Modify the Function to use $f(w,x,y,z) = (w + x + y + z - 7) \mod 8$
#+BEGIN_SRC ipython :exports both :results raw drawer :eval never-export :session persian-recursion :eval never-export :ipyfile ./persian-recursion-new-func.svg
%config InlineBackend.figure_format = 'svg'
def cx(l, r, t, b, m):
    new_col = (main.mat[t,l] + main.mat[t,r] +  main.mat[b,l] + main.mat[b,r]-7) % m
    return new_col.astype(int)
main(8, 8, 1, cx)
#+END_SRC

#+attr_html: :width 400px
#+attr_latex: :width 9cm
#+NAME: new-func-plot
#+CAPTION: Output produced by listing [[new-func-code]] using $f(w,x,y,z) = (w + x + y + z - 7) \mod 8$
#+RESULTS: new-func-code
[[file:./persian-recursion-new-func.svg]]


#+NAME: new-func2-code
#+CAPTION: Modify the function to use $f(w,x,y,z) = (w + 8x + 8y + 8z) \mod 8 + 1$
#+BEGIN_SRC ipython :exports both :results raw drawer :eval never-export :session persian-recursion :eval never-export :ipyfile ./persian-recursion-new-func2.svg
%config InlineBackend.figure_format = 'svg'
import numpy as np
def cx(l, r, t, b, m):
    new_col = (main.mat[t,l] + main.mat[t,r]*m +  main.mat[b,l]*(m) + main.mat[b,r]*(m))**1 % m + 1
    return new_col.astype(int)
main(8, 8, 1, cx)
#+END_SRC


#+attr_html: :width 400px
#+attr_latex: :width 9cm
#+NAME: new-func2-plot
#+CAPTION: Output produced by listing [[new-func2-code]] using $f(w,x,y,z) = (w + 8x + 8y + 8z) \mod 8 + 1$
#+RESULTS: new-func2-code
[[file:./persian-recursion-new-func2.svg]]
** Figures

#+NAME: xkcd-complex-numbers
#+CAPTION: XKCD 2028: Complex Numbers
[[file:complex_numbers.png]]

* Footnotes

[fn:jp] See cite:GnuplotFractalMandelbrot for an excellent, albeit quite old, resource on GNUPlot.

[fn:ft] [[https://www.dropbox.com/s/jd5qf1pi2h68f2c/mandelbrot-400mpx.fits?dl=0][https://www.dropbox.com/s/jd5qf1pi2h68f2c/mandelbrot-400mpx.fits?dl=0]]

[fn:tm] On my system this took about 30 minutes.

[fn:ln] [[https://dl.dropboxusercontent.com/s/rbu25urfg8sbwfu/out.gif?dl=0][https://dl.dropboxusercontent.com/s/rbu25urfg8sbwfu/out.gif?dl=0]]

[fn:wk] This approach was inspired by an animation on the /Julia Set/ Wikipedia article cite:JuliaSet2020

[fn:im] these cascading values are much like brightness in Astronomy

[fn:ma] This technique was adapted from Chapter 7 of /Math adventures with Python/ cite:farrellMathAdventuresPython2019

[fn:vc] See figure [[xkcd-im]] for the obligatory /XKCD/ Comic

[fn:cch] Dr. Hazrat mentions something similar in his book with respect to
/Mathematica/\textsuperscript{\textregistered}
[[cite:hazratMathematicaProblemCenteredApproach2015][Ch. 13]]

[fn:pja] This problem is taken from Project A (44) of Dr. Hazrat's /Mathematica: A Problem Centred Approach/ cite:hazratMathematicaProblemCenteredApproach2015

[fn:op] Although proprietary software such as Magma, Mathematica and Maple is very good, the restrictive licence makes them undesirable for study because there is no means by which to inspect the problem solving tecniques implemented, build on top of the work and moreover the lock-in nature of the software makes it a risky investment with respect to time.

[fn:rv] Although Hardy made a good defence of pure math in his 1940s Apology cite:hardyMathematicianApology2012, it isn't rare at all for pure math to be found applications, for example much number theory was probably seen as fairly pure before RSA Encryption cite:spraulHowSoftwareWorks2015.

